# Morden JavaScript Deep Dive

Dasom, 2024.06.09

## 16장 프로퍼티 어트리뷰트

> 프로퍼티란?
>
> "속성"이라는 뜻으로,
>
> 자바스크립트에서는 객체 내부의 속성을 의미함

* 내부 슬롯과 내부 메서드 = 의사(pseudo) 프로퍼티와 의사 메서드
  * ECMAScript 사양에 등장하는 `[[...]]`
  * 자바스크립트 엔진의 내부 로직 -> 직접적 접근 및 호출 불가
  * cf. 모든 객체의 [[Prototype]] 내부슬롯은 `__proto__`로 간접 접근 가능


* 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
  * 자바스크립트 엔진이 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의함.
    * 즉 프로퍼티 어트리뷰트 = 프로퍼티 상태
    * 프로퍼티 상태: 프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부 (Value, Writable, Enumerable, Configurable)
    * 직접 접근하는 건 불가능하지만 `Object.getOwnPropertyDescriptor(객체의참조, 프로퍼티키)`메서드를 통해 간접 접근 가능 -> 프로퍼티 디스크립터 객체 반환



* 데이터 프로퍼티
  * 키와 값으로 구성된 일반적인 프로퍼티
  * 자바스크립트 엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의 됨
  * 데이터 프로퍼티의 프로퍼티 어트리뷰트:  Value, Writable, Enumerable, Configurable
  * `prototype`으로 확인
* 접근자 프로퍼티
  * 자체적으로는 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티
  * getter/setter 함수라고도 부름
  * 접근자 프로퍼티의 프로퍼티 어트리뷰트: Get, Set, Enumerable, Configurable
  * `__proto__`로 확인



* 프로퍼티 정의

  * 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의 || 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것
  * `Object.defineProperty(객체즤 참조, 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체)`

* 객체 변경 방지

  * 객체는 변경 가능한 값이기 때문에 재할당 없이 직접 변경 가능 = 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티 값 갱신 가능, 프로퍼티 어트리뷰트 재정의 가능

  -> 이것을 방지하는 법

  * 객체 확장 금지 (Object.preventExtensions)
    * 프로퍼티 추가 금지
  * 객체 밀봉 (Object.seal)
    * 읽기와 쓰기만 가능
  * 객체 동결 (Object.freeze)
    * 읽기만 가능
  * 불변 객체: 구현을 위해서는 재귀적으로 Object.freeze 호출 필요



## 17장 생성자 함수에 의한 객체 생성

cf. 10장 객체 리터럴에 의한 객체 생성 방식: `const empty = {}`

* Object 생성자 함수 `new Object()`

> 일반적인 상황에서는 Object 생성자 함수를 사용하는 것보다, 객체 리터럴을 사용하는 것이 더 추천됨
>
> 단, 같은 프로퍼티 구조의 객체 여러개를 동시에 생성할 때에는 생성자 함수가 가지는 이점이 존재함.

* 객체 리터럴에 의한 객체 생성 방식의 문제점
  * 단 하나의 객체만 생성함
  * 따라서 프로퍼티 구조가 동일한 객체를 여러개 생성할 경우 문제가 발생
* 생성자 함수에 의한 객체 생성 방식의 장점
  * 템플릿(클래스)처럼 생성자 함수를 통해 프로퍼티 구조가 동일한 객체 여러개를 쉽게 생성할 수 있음



* 생성자 함수의 인스턴스 생성 과정
  * 인스턴스 생성과 this 바인딩
  * 인스턴스 초기화
  * 인스턴스 반환
    * 명시적으로 객체를 반환하면 암죽적인 this 반환이 무시됨



* 내부 메서드 [[Call]], [[Construct]]

  * 함수는 객체이므로 일반 객체와 동일하게 동작 가능 => 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드 모두 가짐
  * 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다
    * 따라서 함수 객체만을 위한 [[Environment]], [[FormalParameters]]등의 내부 슬롯과 [[Call]], [[Construct]] 내부 메서드를 가지고 있음
    * constructor는 생성자 함수로서 호출할 수 있는 함수
  * 모든 함수 객체는 callable이지만 모든 함수 객체가 constructor인 것은 아님 (모든 함수 객체가 생성자 함수로서 호출할 수 있는 객체인 것은 아님)

* constructor와 non-constructor의 구분

  * constructor: 함수 선언문, 함수 표현식, 클래스
  * non-constructor: 메서드, 화살표 함수

  cf. ECMAScript 사양에서 메서드로 인정하는 범위가 일반적인 의미의 메서드보다 좁음

* new 연산자

  * new연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작함
  * new연산자 없이 호출하면 일반 함수로 호출 => Construct가 아닌 Call이 호출
  * 생성자 함수는 파스칼 케이스로 명명하여 일반 함수와 구별하기

* new.target

  * this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역변수와 같이 사용됨



## 18장 함수와 일급 객체

* 일급객체

  * 무명의 리터럴로 생성할 수 있다 (런타임에 생성이 가능)
  * 변수나 자료구조에 저장할 수 있다
  * 함수의 매개변수에 전달할 수 있다
  * 함수의 반환값으로 사용할 수 있다

  -> 일급 객체로서 함수가 가지는 특징: 일반 객체와 같이 함수의 매개변수에 전달 가능 / 함수의 반환값으로 사용 가능

* 함수 객체의 프로퍼티

  * arguments
    * 인수의 정보를 담고 있는 순회 가능한 유사 배열 객체(for문으로 순회 가능)
    * 가변 인자 함수를 구현할 때 유용함
  * caller
    * 비표준 프로퍼티 (사용하지 말 것)
  * length
    * arguments객체의 length와 함수 객체의 length 프로퍼티의 값은 다를 수 있음. 매개변수의 개수를 가리킴
  * name
    * 함수 이름을 나타냄
  * `__proto__`
    * [[prototype]]내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티
  * prototype
    * constructor만이 소유함









## 느낀점

* "프로퍼티"라는 단어의 뜻을 계속해서 검색하게 된다. 자체적으로 "속성"이라는 말로 바꿔 읽어야만 이해가 가고는 했는데 프로퍼티 자체에도 익숙해지려 해야할 것 같다.

* 그리고, constructor와 non-constructor의 구분 부분이 명확하게 이해가 되지 않았다. 우선 생성자 함수는 constructor는 생성자 함수, non-constructor는 그 외 일반 함수로 우선은 기억하려고 한다.

  



