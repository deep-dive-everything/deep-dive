# 16 - 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

- 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드
- ECMAScript 사양에 등장하는 이중 대괄호([[…]])로 감싼 이름들
- 자바스크립트 엔진의 내부 로직이므로 원칙적으로 직접 접근하거나 호출할 수 있는 방법을 제공하지 않음
    
    → 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공
    
- 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 가짐
    
    → [[Prototype]] 내부 슬롯의 경우 `__proto__` 를 통해 간접적으로 접근 가능

> [!TIP]
> __proto__
> **Object.prototype.__proto__** 는 오늘날 대부분의 브라우저에서 지원되지만, 그 존재와 정확한 동작은 오직 웹 브라우저와의 호환성을 보장하기 위한 레거시 기능으로서 ECMAScript 2015 사양에서 비로소 표준화되었습니다.
> 더 나은 지원을 위해 대신 [`Object.getPrototypeOf()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)를 사용하세요.


## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 자바스크립트 엔진은 프로퍼티 생성시 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의함
- 프로퍼티 상태
    - 프로퍼티의 값
    - 값의 갱신 가능 여부
    - 열거 가능 여부
    - 재정의 가능 여부
- 프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태의 값인 내부 슬롯 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 임
    
    → 프로퍼티 어트리뷰트에 직접 접근은 불가능. Object.getOwnPropertyDescriptor 메서드를 사용해 간접적으로 확인 가능
    
- Object.getOwnPropertyDescriptor
    - 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환
- Object.getOwnPropertyDescriptors(ES8)
    - 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티
    - 키와 값으로 구성된 일반적인 프로퍼티.
- 접근자 프로퍼티
    - 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자함수로 구성된 프로퍼티

### 16.3.1 데이터 프로퍼티

- 데이터 프로퍼티의 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의
    
    
    | 프로퍼티
    어트리뷰트 | 프로퍼티 디스크립터 
    객체의 프로퍼티 | 설명 |
    | --- | --- | --- |
    | [[Value]] | value | 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값 |
    | [[Writable]] | writable | 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 가짐 |
    | [[Enumerable]] | enumerable | 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 가짐 |
    | [[Configurable]] | configurable | 프로퍼티 재정의 가능 여부를 나타내며 불리언 값을 가짐 |

### 16.3.2 접근자 프로퍼티

- 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티
    
    
    | 프로퍼티 어트리뷰트  | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                  |
    | -------------------- | -----------------------------------| --------------------------------------------------------------------- |
    | [[Get]]              | get                                | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수. |
    | [[Set]]              | set                                | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 |
    | [[Enumerable]]       | enumerable                         | 데이터 프로퍼티의 [[Enumerable]]와 같음                                  |
    | [[Configurable]]     | configurable                       | 데이터 프로퍼티의 [[Configurable]]와 같음                                |
    - 접근자 함수는 getter/setter 함수라고도 부름.
    - 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있음

- 접근자 프로퍼티와 데이터 프로퍼티를 구별하는 방법
    
    ```jsx
    // 일반 객체의 __proto__ 는 접근자 프로퍼티
    Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
    // {get: f, set: f, enumerable: false, configurable: true}
    // 함수 객체의 prototype은 데이터 프로퍼티
    Object.getOwnPropertyDescriptor(function(){}, '__proto__');
    // {value: {...}, writable: true, enumerable: false, configurable: true}
    ```
    

## 16.4 프로퍼티 정의

- 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의 하는 것
- Object.defineProperty 메서드를 사용하면 프로퍼티 어트리뷰트를 정의할 수 있음.
    
    ```jsx
    const person = {};
    // 데이터 프로퍼티 정의
    Object.defineProperty(person, 'firstName', {
    	value: 'gyeol',
    	writable: true,
    	enumerable:true,
    	configurable: true
    });
    // value만 정의하고 나머지는 생략 -> 생략된 어트리뷰트는 기본값이 적용된다.
    Object.defineProperty(person, 'firstName', {
    	value: 'park'
    });
    ```
    
- 프로퍼티 디스크립터 객체에서 생략도된 어트리뷰트에 적용되는 기본값
    
    
    | 프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 생략시 기본값 |
    | --- | --- | --- |
    | value | [[Value]] | undefined |
    | get | [[Get]] | undefined |
    | set | [[Set]] | undefined |
    | writable | [[Writable]] | false |
    | enumerable | [[Enumerable]] | false |
    | configurable | [[Configurable]] | false |
- Object.defineProperty 메서드는 한번에 하나의 프로퍼티만 정의 가능
- Object.defineProperties 메서드는 한번에 여러 개의 프로퍼티 정의 가능

## 16.5 객체 변경 방지

- 객체는 변경 가능한 값이므로 재할당 없이 직접 변경이 가능
    
    → 프로퍼티 추가, 삭제 가능 / 프로퍼티 값 갱신 가능 / Object.defineProperty 또는 Object.defineProperties 메서드를 통해 프로퍼티 어트리뷰트 재정의 가능 
    
- 자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공
- 메서드 마다 객체의 변경을 금지하는 강도가 다름
    
    
    | 구분          | 메서드                       | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
    | ------------- | ---------------------------- | ------------- | ------------- | ---------------- | --------------- | -------------------------- |
    | 객체 확장 금지 | Object.preventExtensions     | ❌            | ⭕           | ⭕               | ⭕             | ⭕                        |
    | 객체 밀봉      | Object.seal                  | ❌            | ❌           | ⭕               | ⭕             | ❌                        |
    | 객체 동결      | Object.freeze                | ❌            | ❌           | ⭕               | ❌             | ❌                        |

### 16.5.1 객체 확장 금지

- Object.preventExtension 메서드로 객체의 확장을 금지
- 확장이 금지된 객체는 프로터피 추가가 금지됨
    
    → 프로퍼티 동적 추가와 Object.defineProperty 두 가지 추가 방법 모두 금지
    

### 16.5.2 객체 밀봉

- Object.seal 메서드로 객체를 밀봉
- 밀봉된 객체는 읽기, 쓰기만 가

### 16.5.3 객체 동결

- Object.freeze 메서드로 객체를 동결
- 동결된 객체는 읽기만 가능

### 16.5.4 불변 객체

- 위의 변경 방지 메서드들은 얕은 변경 방지로 직속 프로파티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못함.
→ Object.freeze 메서드로 객체를 동결해도 중첩 객체까지 동결은 불가능
- 객체의 중첩 객체까지 동결하여 변경 불가능한 읽기 전용의 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 **재귀적으로 Object.freeze 메서드를 호출**해야함

# 17 - 생성자 함수에 의한 객체 생성

## 17.1 Object 생성자 함수

- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환함
- 빈 객체 생성 후 프로퍼티 또는 메서드를 추가하여 객체 완성 가능
    
    ```jsx
    // 빈 객체의 생성
    const person = new Object();
    // 프로퍼티 추가
    person.name = 'Park';
    console.log(person); // {name: "Park"}
    ```
    
- 생성자 함수
    - new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수
    - 생성자 함수에 의해 생성된 객체는 인스턴스
- 자바스크립트는 Object 생성자 함수 외 String, Number, Function, Array, Date, RegExp. Promise 등 빌트인 생성자 함수를 제공
- Object 생성자 함수를 사용해 빈 객체를 생성하는 것보다 객체 리터럴을 사용하는 것이 더 간편함

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

- 객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하지만 단 하나의 객체만 생성 가능
    
    → 동일한 프로퍼티를 갖는 객체 여러 개를 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적
    

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

- 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성 가능
- 생성자 함수는 자바와 같은 클래스 기반 객체 지향 언어의 생성자와는 달리 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 **new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작(new 연산자와 함께 생성자 함수를 호출하지 않으면 일반 함수로 동작)**

### 17.2.3 생성자 함수의 인스턴스 생성 과정

- **생성자 함수의 역할은 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당) 하는 것**
- 인스턴스 생성은 필수. 생성된 인스턴스를 초기화 하는 것은 옵션
- new 연산자와 함께 생성자 함수를 호출하면 일어나는 과정
    1. 인스턴스 생성과 this 바인딩
        - 암묵적으로 빈 객체가 생성되며, 이 빈 객체는 this에 바인딩됨(생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유)
    2. 인스턴스 초기화
        - this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당(이 처리는 개발자가 기술함)
    3. 인스턴스 반환
        - 생성자 함수 내부에서 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환함
        - this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시한 객체가 반환됨
        - 명시적으로 원시 값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환됨
        - 생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손 → 생성자 함수 내부에서 return 문을 반드시 생략해야함

### 17.2.4 내부 메서드 [[Call]] 과 [[Contruct]]

- 함수는 객체이므로 일반 객체와 동일하게 동작 가능
    
    → 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있기 때문
    
- 함수는 객체이지만 일반 객체와는 다름(함수는 호출 가능. 일반 객체는 호출 불가능)
- 함수는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드, 그리고 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 가짐
- 함수가 일반 함수로서 호출되면?
    - 함수 객체의 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]] 가 호출됨
- 함수 객체는 callable이면서 constructor이거나 callable 이면서 non-constructor임
    
    → 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아님
    

### 17.2.5 constructor와 non-constructor의 구분

- constructor
    - 함수 선언문, 함수 표현식, 클래스(클래스도 함수임)
- non-constructor
    - 메서드(ES6 메서드 축약 표현), 화살표 함수

### 17.2.6 new 연산자

- new 연산자와 함께 함수를 호출하면 해당 함수는 생성자함수로 동작
    
    → 함수 객체의 내부 메서드 [[Call]] 이 호출되는것이 아니라 [[Constructor]]가 호출됨. 단 new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이어야함
    
- 반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출됨
    
    →함수 객체의 내부 메서드 [[Constructor]]이 호출되는것이 아니라 [[Call]] 가 호출됨.
    

### 17.2.7 new.target

- 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인 가능
- new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킴. new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined

# 18 - 함수와 일급 객체

## 18.1 일급 객체

- 일급 객체 조건
    1. 무명의 리터럴로 생성 가능 → 런타임에 생성 가능
    2. 변수나 자료구조(객체, 배열 등)에 저장 가능
    3. 함수의 매개변수에 전달 가능
    4. 함수의 반환값으로 사용 가능
- 자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체임
- 함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 것을 의미 → 함수는 값을 사용할 수 있는 곳이라면 어디서든지 리터럴로 정의 가능하며 런타임에 함수 객체로 평가됨
- 함수는 객체이지만 일반 객체와는 차이가 있음
    - 일반 객체는 호출이 불가능하지만 함수 객체는 호출이 가능
    - 함수 객체는 일반 객체에는 없는 함수 고유의 프로퍼티를 소유

## 18.2 함수 객체의 프로퍼티

- 함수는 객체이기 때문에 프로퍼티를 가질 수 있음

### 18.2.1 arguments 프로퍼티

- 함수 객체의 arguments 프로퍼티 값은 arguments 객체
- arguments 객체
    - 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체.
    - 함수 내부에서 지역변수처럼 사용됨(함수 외부에서는 참조 불가능)
- 자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않음 
→ 함수 호출 시 매개변수 개수 만큼 인수를 전달하지 않아도 에러가 발생하지 않음
- 초과된 인수가 그냥 버려지진 않으며 암묵적으로 arguments 객체의 프로퍼티로 보관됨
- arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수 구현시 유용

### 18.2.2 caller 프로퍼티

- 함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킴
- ECMAScript 사양에 포함되지 않은 비표준 프로퍼티
- 표준화될 예정 X → 참고로만 알아두면 됨

### 18.2.3 length 프로퍼티

- 함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킴
- arguments 객체의 length 프로퍼티는 함수 객체의 length 프로퍼티의 값은 다를 수 있음.

### 18.2.4 name프로퍼티

- 함수 객체의 name 프로퍼티는 함수 이름을 나타냄
- ES6 이전까지는 비표준이었지만 ES6에서 정식 표준이 되었음(ES5와 ES6에서 동작을 달리함)
    - 익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열을 값으로 가짐. ES6에서는 함수 객체를 가리키는 식별자를 값으로 가짐

### 18.2.5 __**proto**__ 접근자 프로퍼티

- [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티
- __proto__ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근이 가능

### 18.2.6 prototype 프로퍼티

- prototype 프로퍼티는 생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티
- 일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티가 없음
- prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킴


# 💭 느낀점

- 개인적으로 생성자 함수로 객체를 생성하는 방법보다는 객체 리터럴을 사용해서 생성하는 방법을 많이 사용해왔는데 따로 이유는 없었다. (객체 리터럴을 사용하는 방식이 더 손에 익었던 것 같다)
이번 스터디를 통해 객체 리터럴에 의한 객체 생성 방식의 문제점과 생성자 함수로 객체를 생성하는 것에 대한 장점을 알게 되었고 필요에 따라 생성자 함수로 객체를 생성하는 방법도 사용해봐야겠다고 느꼈다!
