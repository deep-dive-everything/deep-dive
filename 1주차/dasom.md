# Morden JavaScript Deep Dive

Dasom, 2024.05.19

## 1-3장 요약 (프로그래밍과 자바스크립트)

* 프로그래밍이란? 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션
  * 프로그래밍에 앞서 요구사항을 명확히 이해하고, 적절한 문제 해결 방안을 정의해야 함

* JavaScript의 등장

  * 1995년, 넷스케이프社의 브랜든 아이크(Brendan Eich)에 의해 개발

  * 브라우저에서 동작하는 경량 프로그래밍 언어의 도입

  * 1997년 비영리 표준화 기구 ECMA 인터내셔널의 ECMAScript1 발표

    cf. ECMAScipt와 JavaScript의차이: JavaScript는 ECMAScript 사양을 준수하는 스크립트 언어 (출처: [JavaScript와 ECMAScript는 무슨 차이점이 있을까?](https://wormwlrm.github.io/2018/10/03/What-is-the-difference-between-javascript-and-ecmascript.html))

* JavaScript의 발전

  * 2008년 구글의 V8 자바스크립트 엔진 등장

    *  데스크톱 어플리케이션과 유사한 UX 제공 가능

      cf. Chorme: V8, FireFox: Spider Monkey

  * 2009년 라이언 달(Ryan Dahl)의 Node.js 등장

    * V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
    * 자바스크립트 엔진을 브라우저에서 독립시킴

* JavaScript의 특징

  * 인터프리터 언어: 런타임에 한 줄씩 읽힘

    cf. 모던 브라우저에서 사용되는 인터프리터는 일부 소스코드를 컴파일하고 실행함으로써 인터프리터의 실행 속도 한계를 극복

  * 프로토타입 기반의 객체지향 언어이자

  * 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어



## 4장 변수

* 컴퓨터 어플리케이션의 동작: 데이터의 입력 -> 처리 -> 결과 출력

  * CPU를 사용해 연산, 메모리를 사용해 데이터를 기억

  * 메모리 = 메모리 셀(크기 1Byte)의 집합

  * 각 메모리 셀은 고유 메모리 주소를 가짐

    cf. 자바스크립트는 개발자의 직접적 메모리 제어를 허용하지 않음 (허용 언어: c, c++ 등)

  ⇒ 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** | **메모리 공간을 식별하기 위해 붙인 이름**을 **변수**라고 함

  즉, 변수는 하나의 식별자

* 식별자

  * 어떤 값을 구별해서 식별할 수 있는 고유한 이름
  * 변수, 함수, 클래스 등의 이름은 모두 식별자



* 변수의 사용
  * 변수의 선언 (var, let, const)
    * 변수 이름을 등록하고 저장할 메모리 공간을 확보
  * 초기화
    * 값을 할당하지 않았다면 undefined 값이 암묵적으로 할당되어 초기화
  * **값**의 할당
    * 할당연산자 `=`로 값을 할당함 
    * 할당은 선언 시점과 달리 런타임에 실행됨
    * 값 = 식(표현식)이 평가되어 생성된 결과 (5장 표현식과 문)
  * 재할당
    * 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수



* 호이스팅

  * 자바스크립트 엔진: 소스코드를 한 줄씩 실행하기 이전에 소스코드의 평가 과정을 거침
  * 평가 과정에서 모든 선언문을 찾아 먼저 실행 

  cf. let, const도 호이스트 되지만 선언 이전의 변수 사용을 금지하는 temporal dead zone에 있기 때문에, 선언 전에 사용을 시도하면 참조 에러(Reference Error)가 발생함 (참고: [MDN](https://developer.mozilla.org/ko/docs/Glossary/Hoisting))



* 가비지 콜렉터
  * 어플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능



## 5장 표현식과 문

* 값: 식(표현식)이 평가되어 생성된 결과

* 리터럴: 사람이 이해할 수 있는 문자 | 약속된 기호를 사용해 값을 생성하는 표기법

  e.g. 정수 리터럴: 3, 100, 7000 / 문자열 리터럴: "Hello", 'dasom' / null 리터럴: null / 배열 리터럴: [1, 2] 

* 표현식

  * 값으로 평가될 수 있는 모든 문(statement)

    즉, 리터럴도 표현식

  * 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있음

    ```js
    const x = 1 + 2;
    x + 3; // x + 3 역시 표현식, 3으로 평가될 수 있는 x 역시 표현식
    ```

* 문(statement) ≒ 명령문

  * 프로그래밍을 구성하는 기본 단위이자 최소 실행 단위
  * 여러 토큰으로 구성됨
    * 토큰: 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 (식별자, 리터럴, 연산자, 세미콜론 등)
  * 문의 종류: 선언문, 할당문, 조건문, 반복문 등



* 표현식인 문 & 표현식이 아닌 문

  * 구분 방법: 변수 할당

    * 표현식인 문: 값으로 평가되기 때문에 변수에 할당 가능

    * 표현식이 아닌 문: 할당 불가능

    cf. 할당문 자체도 표현식인 문 (e.g. `x = 3`)

    ```js
    const x; // 변수 선언문 !== 표현식
    x = 1 + 2;
    // 1, 2, 1 + 2, x = 1 + 2 모두 표현식
    ```

    

## 6장 데이터 타입



### 원시타입

* 숫자 타입

  * 자바스크립트의 숫자타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리함

    따라서 `console.log(1 === 1.0); // true`

  * Infinity, -Infinity, Nan(not-a-nature) 값 표현 가능

* 문자열 타입

  * 작은따옴표, 큰따옴표, 백틱으로 감싸서 표현 가능
  * 감싸지 않으면 식별자로 인식

  cf. 템플릿 리터럴: 백틱으로 감싸서 사용, 이스케이프 시퀀스를 사용하지 않고도 줄바꿈과 공백이 허용 됨

* 불리언 타입

  * 논리적 참 거짓을 나타내는 true와 false만이 존재

* undefined 타입

  * 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값.
  * 변수에 값이 없다는 것을 명시하고 싶다면 null을 할당하는 것이 권장됨

* null 타입

  * 변수에 값이 없다는 것을 의도적으로 명시할 때 사용

  cf. document.querySelector 메서드는 조건에 부합하는 HTML 요소가 없을 때 null을 반환

* 심벌 타입

  * ES6에서 추가된 7번째 타입
  * 변경 불가능한 원시 타입의 값
  * 다른 원시 값은 리터럴을 통해 생성하지만 심벌은 `Symbol`함수를 호출해 생성



### 객체 타입

* 원시 타입 외의 모든 값은 모두 객체 타입



* 데이터 타입의 필요성

  * 값을 저장할 때 확보할 메모리 공간의 크기 결정
  * 값을 참조할 때 한 번에 읽을 메모리 공간의 크기 결정
  * 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정

* 변수의 데이터 타입

  * C나 자바: 정적 타입 언어로, 변수 선언 시 변수에 할당 가능한 데이터 타입을 사전에 선언

  * JavaScript: 타입을 선언하지 않기 때문에 어떤 타입의 값이라도 자유롭게 할당

    즉, 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정됨. 

  ⇒ 변수는 타입을 갖지 않음 / 값은 타입을 가짐

