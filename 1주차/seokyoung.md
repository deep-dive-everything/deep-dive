## 04 변수

### 4.1 변수란 무엇인가? 왜 필요한가?

- 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념
- 자바스크립트 엔진이 자바스크립트 코드 `10 + 20`를 계산(평가)하려면 먼저 `10`, `20`, `+` 라는 기호(리터럴과 연산자)의 의미를 알고 있어야 하며, `10 + 20`이라는 식(표현식)의 의미도 해석(파싱)할 수 있어야 한다.
- 사람은 계산과 기억을 모두 두뇌에서 하지만, 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.
- 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이며, 1바이트 단위로 데이터를 저장하거나 읽어들인다.
- `10 + 20`을 연산했다 -> 연산 결과가 필요 -> 이를 사용해 무언가를 하겠다는 의도 -> 재사용하고 싶다면 메모리 주소를 통해 접근해야 함
- 하지만 메모리 공간에 직접 접근하는 것은 위험한 일
- 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.
- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.
- 변수는 값의 위치를 가리키는 상징적인 이름
- 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름(변수명), 변수에 저장된 값을 변수 값, 변수에 값을 저장하는 행위를 할당(_assignment_)이라 하고, 변수에 저장된 값을 읽어 들이는 행위를 참조(_reference_)라고 한다.
- 변수에 저장된 값의 의미를 파악할 수 있는 변수 이름은 가독성을 높이는 부수적인 효과도 있다.

### 4.2 식별자

- 변수 이름을 식별자(_identifier_)라고도 한다.
- 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
- 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다. 값이 아니라 메모리 주소를 기억하고 있다.
- 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.
- 변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, 선언(_declaration_)에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

### 4.3 변수 선언

- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.
- 변수를 사용하려면 반드시 선언이 필요하며, 변수를 선언할 때는 var, let, const 키워드를 사용한다.
- 자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.
  - 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
  - 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.
- 변수 이름을 비롯한 모든 식별자는 실별자와 스코를 관리하는 실행 컨텍스트에 등록된다.
- 만약 선언하지 않은 식별자에 접근하면 `ReferenceError`(참조 에러)가 발생한다. `ReferenceError` 는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

- 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다.
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅 _variable hoisting_ 이라고 한다.

### 4.5 값의 할당

- 변수에 값을 할당(대입, 저장)할 때는 할당 연산자 =를 사용한다.

```javascript
var score // 변수 선언
score = 80 // 값의 할당
```

- 변수 선언과 값의 할당을 하나의 문(_statement_)로 단축 표현할 수도 있다.

```javascript
var score = 80 // 변수 선언과 값의 할당
```

- 변수 선언과 값의 할당의 실행 시점이 다르다는 점을 주의해야 한다.
- 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
- 변수의 선언과 값의 할당을 하나의 문장으로 단축 표현해도 자바스크립트 엔진은 변수의 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.

```javascript
console.log(score) // undefined

var score = 80 // 변수 선언과 값의 할당

console.log(score) // 80
```

```javascript
console.log(score) // undefined

score = 80 // (2) 런타임에 할당되어 순차적으로 실행
var score // (1) 호이스팅으로 런타임 이전에 실행

conosle.log(score) // (3) 80
```

### 4.6 값의 재할당

```javascript
var score = 80 // 변수 선언과 값의 할당
score = 90 // 값의 재할당
```

- `var` 선언한 변수는 값을 재할당 할 수 있다. 또한 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.
- 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.
- `const`는 재할당이 금지되기 때문에 상수를 표현할 수 있다.

### 4.7 식별자 네이밍 규칙

- 식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.
  - 특수문자를 제외한 문자, 숫자 언더스코어(`\_`), 달러 기회(`$`)를 포함할 수 있다.
  - 단, 식별자는 숫자로 시작하는 것은 허용하지 않는다.
  - 예약어는 식별자로 사용할 수 없다.

## 05 표현식과 문

### 5.1 값

- 값은 표현식이 평가되어 생성된 결과를 말한다.

```javascript
// 10 + 20은 평가되어 숫자 값 30을 생성한다.
10 + 20 // 30
```

- 변수에 할당되는 것은 값이다.

```javascript
// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20
```

### 5.2 리터럴

- 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.
- 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.
- 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.

### 5.3 표현식

- 표현식은 값으로 평가될 수 있는 문이다.
- 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
- 리터럴도 값으로 평가된다. 따라서 리터럴도 표현식이다.

### 5.4 문

- 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.
- 문은 여러 토큰으로 구성된다.
- 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
- 문은 선언문, 할당문, 조건문 , 반복문 등으로 구분할 수 있다.

### 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론은 문의 종료를 나타낸다.
- 자바스크립트 엔진이 소스코드를 해설할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능이 암묵적으로 수행된다.

### 5.6 표현식인 문과 표현식이 아닌 문

- 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.
- 표현식인 문과 표현식이 아닌 문을 나누는 기준은 값으로 평가될 수 있는지의 유무로 결정된다.
- 표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.
  - 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문이다
  - 할당문은 값으로 평가될 수 있으므로 그 자체로 표현식인 문이다.

## 06 데이터 타입

- 데이터 타입은 값의 종류
- 자바스크립트(ES6)는 7개의 데이터 타입 제공하고 원시 타입과 객체 타입으로 분류할 수 있다. - 원시 타입: number, string, boolean, undefined, null, symbol - 객체 타입: object, function, array, ...

### 6.1 숫자 타입

- 자바스크립트는 하나의 숫자 타입만 존재한다.
- ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다.
- 즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다. 이는 정수로 표시된다 해도 사실은 실수라는 것을 의미한다.
- 숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다.

```js
Infinity - // 양의 무한대
  Infinity // 음의 무한대
NaN // 산술 연산 불가(not-a-number)
```

- 자바스크립트는 대소문자를 구별하므로 `NaN` 이외에 `NAN`, `Nan`, `nan` 등은 값이 아닌 식별자로 해석한다.

### 6.2 문자열 타입

- 문자열 타입은 텍스트 데이터를 나타내는데 사용한다.
- 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다.

```js
var string
string = '문자열' // 작은따옴표
string = '문자열' // 큰따옴표
string = `문자열` // 백틱(ES6)
```

### 6.3 템플릿 리터럴

- ES6부터 도입된 표기법으로 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다.
- 런타임에 일반 문자열로 변환되어 처리된다.

### 6.4 불리언 타입

- 불리언 타입의 값은 논리적 참, 거짓을 나타내는 `true`와 `false`뿐이다.
- 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용한다.

### 6.5 undefined 타입

- `undefined` 타입의 값은 `undefined`가 유일하다.
- `var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화된다.
- 이처럼 `undefined`는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.
- 그러므로 변수에 값이 없다는 것을 명시하고 싶을 때는 `undefined`보다 `null`을 할당한다.

### 6.6 null 타입

- `null` 타입의 값은 `null`이 유일하다.
- 프로그래밍 언어에서 `null`은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재)할 때 사용한다.
- 변수에 `null`을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다.
- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 한다. - `document.querySelector`

### 6.7 심벌 타입

- ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.
- 다른 값과 중복되지 않는 유일무이한 값이기 때문에 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

### 6.8 객체 타입

- 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.

### 6.9 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

### 6.10 동적 타이핑

- 자바스크립트는 동적 타입 언어로, 변수를 선언할 때 타입을 선언하지 않는다.
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다.
- 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
- 이러한 특징을 동적 타이핑이라 하며, 자바스크립트는 동적 타이핑 언어이다.
- 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다.
- 동적 타입 언어의 구조적인 단점
  - 변수 값은 언제든지 변경될 수 있기 때문에 추적하기 어려울 수 있다.
  - 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
  - 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.
  - 유연성은 높지만 신뢰성은 떨어진다.
- 동적 타입 언어에서 변수 사용 시 주의 사항

  - 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
  - 변수의 유효 범위(스코프)를 최대한 좁게 만들어 부작용을 억제한다.
  - 전역 변수는 최대한 사용하지 않는다.
  - 변수보다는 상수를 사용해 값의 변경을 억제한다.
  - 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

## 07 연산자

- 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

### 7.1 산술 연산자

- 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
- 산술 연산이 불가능할 경우 `NaN`을 반환한다.
- 이항 산술 연산자
  - `+` (덧셈), `-` (뺄셈), `*` (곱셈), `/` (나눗셈), `%` 나머지
- 단항 산술 연산자
  - `++` : 증가
  - `--` : 감소
  - `+` : 숫자 타입이 아닌 피연산자를 숫자 타입으로 변환하여 반환
  - `-` : 양수를 음수로, 음수를 양수로 반전한 값을 반환
- 문자열 연결 연산자
  - `+` 연산자는 피연산자 중에 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
  - 자바스크립트 엔진에 의해 암묵적 타입 변화(또는 타입 강제 변환)이 동작한 것이다.

### 7.2 할당 연산자

- 우항에 있는 피연산자들의 평가 결과를 좌항에 있는 변수에 할당한다.
- 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다.
- 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

```js
var a = (b = c)

// 연쇄 할당
a = b = c = 0

console.log(a, b, c) // 0 0 0
```

### 7.3 비교 연산자

- 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.
- if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.

#### 7.3.1 동등/일치 비교 연산자

- 동등/일치 비교 연산자는 좌항과 우항의 비연산자가 같은 값으로 평가되는지 비교해 불리언 값으로 반환한다.
- 두 비교하는 연산자는 비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 값만 비교하는 느슨한 비교를 하지만 일치 비교 연산자는 값과 타입 모두 비교하는 엄격한 비교를 한다.
- 동등 비교 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
- 동등 비교 연산자는 예측하기 어려운 결과를 만들어낸다. 따라서 동등 비교 연산자는 사용하지 않는 편이 좋다.
- 일치 비교 연산자에서 주의할 것은 `NaN`이다. `NaN`은 자신과 일치하지 않는 유일한 값이므로 숫자가 `NaN`인지 확인하려면 `Number.isNaN`을 사용한다.
- 자바스크립트는 양의 0과 음의 0을 비교하면 true를 반환하므로, 이 둘을 비교할 때는 `Object.is`로 비교한다.

#### 7.3.2 대소 관계 비교 연산자

- 피연산자를 비교하여 불리언 값을 반환한다.

### 7.4 삼항 조건 연산자

- 조건식의 평가 결과에 따라 반환할 값을 결정한다.

```js
var result = 2 ? 'pass' : 'fail'
```

### 7.5 논리 연산자

- 우항과 좌항의 피연산자를 논리 연산한다.
- `||` : 논리합(OR)
- `&&` : 논리곱(AND)
- `!` : 부정(NOT)
- 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.
- 논리합(`||`) 또는 논리곱(`&&`) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다. (단축 평가)

### 7.6 쉼표 연산자

- 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가 결과를 반환한다.

```js
var x, y, z
;(x = 1), (y = 2), (z = 3) // 3
```

### 7.7 그룹 연산자

- 소괄호(`()`)로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.
- 그룹 연산자를 통해 연산자의 우선순위를 조절할 수 있다.

### 7.8 typeof 연산자

- 피연산자의 데이터 타입을 문자열로 반환한다.
- string, number, boolean, undefined, symbol, object, function 중에 하나를 반환한다.
- `null`은 반환하는 경우가 없으므로 typeof 연산자가 아닌 일치 연산자를 사용해야 한다.
- 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 `ReferenceError`가 발생하지 않고 undefined를 반환한다.

### 7.9 지수 연산자

- ES7에서 도입된 연산자로 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.
- 지수 연산자가 도입되기 이전에는 `Math.pow` 메서드를 사용했다.

```js
// 지수 연산자
2 ** (3 ** 2) // 512

// Math.pow 메서드
Math.pow(2, Math.pow(3, 2)) // 512
```

### 7.10 그 외의 연산자

- `?.`: 옵셔널 체이닝 연산자
- `??`: null 병합 연산자
- `delete`: 프로퍼티 삭제
- `new`: 생성자 함수를 호출할 때 사용하여 인스턴스 생성
- `instanceof`: 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
- `in`: 프로퍼티 존재 확인

### 7.11 연산자의 부수효과

- 부수 효과가 있는 연산자
  - 할당 연산자
  - 증가/감소 연산자
  - delete 연산자
