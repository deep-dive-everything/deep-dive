# 33 Symbol

## 1. 심벌

- 변경 불가능한 원시 타입의 값
- 이름 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용

## 2. 심벌 값의 생성

### 2.1 Symbol 함수

- 리터럴 표기법이 아닌 Symbol 함수를 호출하여 생성해야 함.
- 이떄 생성된 Symbol값은 다른값과 중복되지 않는 유일무이한 값
- 문자열을 인수로 전달할 수 있음. 심벌 값에 대한 설명. 값 생성에 영향 주지 않음.

### 2.2 Symbol.for / Symbol.keyFor 메서드

- Symbol.for : 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌을 검색
    - 검색에 성공하면 새로운 값을 생성하지 않고 검색된 값을 반환
    - 검색 실패하면 새로운 심벌 값을 생성하고 생성된 값을 반환

## 3. 심벌과 상수

- 상수 이름 자체에 의미가 있는 경우. 변경/중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 심벌 사용

## 4. 심벌과 프로퍼티 키

- 심벌값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 충돌하지 않음.

## 5. 심벌과 프로퍼티 은닉

- 심벌 값을 키로 생성한 프로퍼티는 for in 문이나 Object.keys등의 메서드로 찾을 수 없음. 외부에 노출할 필요 없는 프로퍼티를 은닉할 수 있음.

# 34 이터러블

## 1. 이터레이션 프로토콜

- 순회가능한 데이터 컬렉션을 만들기 위해 ECMAScript사양에 정의하여 미리 약속한 규칙.

### 1.1 이터러블

- 이터러블 : 이터러블 프로토콜을 준수한 객체
- for…of문으로 순회 가능. 스프레드문법, 배열 드스트럭처링 할당의 대상으로 사용

### 1.2 이터레이터

- 이터레이터 : 이터러블의 Symbol.iterator메서드 호출하면 반환되는 값. 이터레이터 프로토콜을 준수한 객체.
- next 메서드를 가짐 : 호출시 이터레이터 리절트 객체 반환
- 이터러블의 요소 탐색을 위한 포인터

## 3. for…of문

- 이터러블을 순회하면서 이터러블 요소를 변수에 할당

```jsx
for (변수선언문 of 이터러블) { ... }
```

## 4. 이터러블과 유사배열 객체

- 유사배열객체 : 인덱스로 프로퍼티 값에 접근할수 있고 length프로퍼티를 가짐.
- 유사배열객체는 for…of문으로 순회 불가함

## 5. 이터레이션 프로토콜의 필요성

- 데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할을 함.
- 다양한 데이터 공급자가 하나의 순회방식을 갖도록 규정. 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있음

# 35 스프레드 문법

- 하나로 뭉쳐 있는 여러 값의 집합을 분산하여 개별적인 값들의 목록을 만듬.
- Array, String, Map, Set, DOM컬렉션
- 사용 가능한 케이스
    - 함수 호출문의 인수 목록
    - 배열 리터럴의 요소 목록
    - 객체 리터럴의 프로퍼티 목록

## 1. 함수 호출문의 인수 목록에서 사용

- 배열을 펼쳐서 개별적인 값을 넣고싶은 경우

```jsx
const arr = [1,2,3];
const max = Math.max(...arr);
```

## 2.배열 리터럴의 요소 목록에서 사용

- concat : 2개의 배열 1개로 결합

```jsx
var arr = [1,2].concat([3,4);//[1,2,3,4]
const arr = [...[1, 2], ...[3, 4]];
```

- splice

```jsx
const arr1 = [1, 4];
const arr2 = [2, 3];

arr1.splice(1, 0, ...arr2);//[1,2,3,4]
```

- 배열복사

```jsx
const origin = [1,2];
const copy = [...origin];
```

# 36 디스트럭처링 할당

- 구조화된 배열과 같은 이터러블 또는 객체를 비구조화하여 1개 이상의 변수에 개별적으로 할당하는 것.

## 1. 배열 디스트럭처링 할당

- 배열 디스트럭처링 할당의 대상(우변)은 이터러블이어야 하며 할당 기준은 배열의 인덱스
- 우변에 이터러블을 할당하지 않은면 에러

```jsx
const arr = [1,2,3];
const [one, two, three] = arr;

console.log(one, two, three)//1, 2, 3
```

## 2. 객체 디스트럭처링 할당

- 할당문의 우변은 객체. 할당 기준은 프로퍼티 키

```jsx
const user = { firstName : 'Harry', lastName: 'Kim'};
const { lastName, FirstName } = user;
```

# 37 Set과 Map

## 1. set

- 중복되지 않은 유일한 값들의 집합.
- 수학적 집합을 구현하기 위한 자료구조

### 1.1 set객체의 생성

- Set 생성자 함수로 생성
- 이터러블을 인수로 전달받아 Set객체 생성. 이때 이터러블의 중복된 겂은 Set객체에 요소로 저장되지 않음.
- 배열에서 중복요소 제거시 사용 가능

### 1.2 요소 개수 확인

- Set.prototype.size

```jsx
const {size} = new Set([1,2,3,3]); // size : 3
```

### 1.3 요소추가

- Set.prototype.add
- 새로운 요소가 추가된 Set객체 반환
- 중복된 요소 추가 허용하지 않음

### 1.7 요소순회

- Set.prototype.forEach
    - 첫번째 인수 ; 현재 순회중인 요소값
    - 두번째 인수 ; 현재 순회중인 요소값
    - 세번째 인수 ; 현재 순회중인 Set객체 자체

## 2. Map

- 키와 값의 쌍으로 이루어진 컬렉션

| 구분 | 객체 | Map객체 |
| --- | --- | --- |
| 키로 사용할수 있는 값 | 문자열 또는 심벌 | 객체 포함 모든 값 |
| 이터러블 | x | o |
| 요소 개수 확인 | Object.keys(obj).length | map.size |

### 2.1 Map 객체의 생성

- Map 생성자 함수로 생성
- 이터러블을 인수로 전달받아 Map객체 생성. 이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야함

```jsx
const map1 = new Map([['key1', 'value1'], ['key2', 'value2']]);
```

### 2.2 요소 개수 확인

- Map.prototype.size

```jsx
const {size} = new Map([['key1', 'value1'], ['key2', 'value2']]);
```

### 2.3 요소추가

- Map.prototype.set
- 새로운 요소가 추가된 Map객체 반환
- 중복된 요소 추가시 덮어씌워짐.

### 2.7 요소순회

- Set.prototype.forEach
    - 첫번째 인수 ; 현재 순회중인 요소값
    - 두번째 인수 ; 현재 순회중인 요소값
    - 세번째 인수 ; 현재 순회중인 Set객체 자체

# 느낀점

생소한 개념이 나왔는데 언제 쓰는지가 궁금해졌습니다. 그리고 전반적인 느낀점이지만, 요즘 프론트 업무를 하고있는데 일주일에 한번 정리하고 모여서 이야기 나누던 내용이 자주 나와서 반갑고 도움도 많이 되어서 뿌듯했습니다!
