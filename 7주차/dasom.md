# Morden JavaScript Deep Dive

Dasom, 2024.06.30

## 25장 클래스

> 자바스크립트는 프로토타입 기반의 객체 지향 언어이다.
>
> 즉, 프로토타입 기반 객체지향 언어는 클래스가 필요없는 객체지향 프로그래밍 언어이다.



### 클래스는 프로토타입의 문법적 설탕인가?

> 문법적 설탕(Syntatic Sugar)이란?
>
> 기존 언어의 구성요소를 조금 더 쉽고 편하게 사용할 수 있도록 추가적으로 제공하는 기능

* ES6 클래스 도입: 자바나 C#과 같은 클래스 기반 객체지향 프로그래밍과 흡사한 매커니즘
* 클래스를 프로토타입 기반 객체 생성 패턴의 문법적 설탕이라기 보다는 새로운 객체 생성 매커니즘으로 보는 것이 합당



### 클래스 정의

```js
// 클래스 선언문
class Person{}

// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

* 클래스는 일급 객체다 (= 클래스를 표현식의로 정의할 수 있다, 함클래스는 함수다)
  * 무명의 리터럴로 생성 가능 (런타임 생성 가능)
  * 변수나 자료구조에 저장 가능
  * 함수의 매개변수에 전달 가능
  * 함수의 반환값으로 사용 가능

```js
// 클래스 선언문
class Person {
  // 생성자
  constructor(name){
    this.name = name;
  }
  
  // 프로토타입 메서드
  sayHi() {
 		console.log('Hi! my name is ${this.name}');
  }
  
  // 정적 메서드
  static sayHello() {
    console.log('Hello~!')
  }
}
```

* 클래스와 생성자 함수의 정의 방식은 형태적인 면에서 유사함



### 클래스 호이스팅

* 클래스는 함수로 평가됨 -> 따라서 런타임 이전(소스코드 평가 과정)에 먼저 평가되어 함수 객체를 생성함
* 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅 됨 (따라서 정의 의전에 참조 시 reference error 발생)



### 인스턴스 생성

```js
class Person {}

// 클래스는 생성자 함수로, new 연산자와 함께 호출되어 인스턴스를 생성함
const me = new Person();

// new 연산자 없이 호출하면 타입 에러가 발생함
const you = Person();
```



### 메서드

* 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있음
* 정의할 수 있는 메서드
  * constructor(생성자), 프로토타입 메서드, 정적 메서드

```js
// constructor
class Person{
  /* 생성자: 인스턴스를 생성하고 초기화하기 위한 특수 메서드
  * 메서드로 해석되는 것이 아니라, 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨
  * 해당 생성자는 클래스 내에 최대 한 개만 존재 가능
  * 생략 시, 빈 constructor가 암묵적으로 생성됨
  * 명시적으로 원시값을 반환하여도 무시되고 암묵적으로 this가 반환됨
  */
  constructor(name){
    this.name = name;
  }
  
  /* 프로토타입 메서드
  * prototype프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 됨
  */
  sayHi(){
    console.log(`Hi! this is ${this.name}`)
  }
  
  /* 정적 메서드
  * static을 붙이면 정적 메서드가 됨
  * 정적 메서드는 클래스에 바인딩된 메서드가 됨.
  * 정적 메서드는 인스턴스 없이도 호출 가능
  * 인스턴스로 클래스의 메서드를 상속받을 수 없음
  */
  static sayHello = function(){
    console.log("Hello!")
  }
}

// 인스턴스 생성

const me = new Person()
// 정적 메서드는 상독되지 않음
me.sayHello(); // TypeError

```

* 클래스에서 정의한 메서드의 특징
  * function 키워드를 생략한 메서드 축약 표현을 사용
  * 객체 리터럴과 달리 클래스에 메서드를 정의할 때는 콤마가 필요 하지 않음
  * 암묵적으로 strict mode로 실행됨
  * for...in 문이다 Object.keys 메서드 등으로 열거 불가(Enumerable의 값이 false)
  * 내부 메서드 [[Constructor]]를 갖지 않는 non-constructor. 따라서 new와 함께 호출 불가



### 클래스의 인스턴스 생성 과정

* 인스턴스 생성과 this 바인딩
* 인스턴스 초기화
* 인스턴스 반환



### 프로퍼티

* 인스턴스 프로퍼티
  * constructor 내부에서 정의해야 함
* 접근자 프로퍼티
  * 접근자 함수로 구성된 프로퍼티
* 클래스 필드 정의 제안
  * 클래스 필드란: 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어
  * 기존에는 이를 지원하지 않았지만, 2021년 이후 클래스 필드를 클래스 몸체에 정의할 수 있어짐
* private 필드 정의 제안
  * 기존에는 접근 제한자를 지원하지 않았으나 21년 이후 private 필드를 정의할 수 있게 됨
* static 필드 정의 제안
  * 이 역시 21년부터 사용 가능



### 상속에 의한 클래스 확장

>  클래스 상속은 프로토타입 기반 상속과는 다른 개념으로, 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것.

* 상속 방법
  * extends 키워드를 통한 확장
  * 동적 상속: 생성자 함수를 상속받아 클래스를 확장함
* super 키워드
  * super키워드는 함수처럼 호출 가능 / this처럼 참조 가능
  * super를 호출하면 수퍼클래스의 constructor를 호출
  * super를 참조하면 수퍼클래스의 메서드를 호출

* 상속 클래스의 인스턴스 생성 과정
  * 서브클래스의 super호출
  * 수퍼클래스의 인스턴스 생성과 this 바인딩
  * 수퍼클래스의 인스턴스 초기화
  * 서브클래스 constructor로의 복귀와 this 바인딩
  * 서브클래스의 인스턴스 초기화
  * 인스턴스 반환



## 26장 ES6함수의 추가 기능

### 함수의 구분

* ES6 이전: 모든 함수는 일반 함수로서 호출할 수 있으며, 생성자 함수로도 호출 가능

  * 문제점: 함수 사용 목적에 따른 구분이 없어, 호출 방식에 특별한 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성함. 혼란의 야기와 성능적 문제 존재.

* ES6 이후

  |             | cnstructor | prototype | super | argument |
  | ----------- | ---------- | --------- | ----- | -------- |
  | 일반 함수   | O          | O         | X     | O        |
  | 메서드      | X          | X         | O     | O        |
  | 화살표 함수 | X          | X         | X     | X        |



### 메서드

* ES6 이전: 메서드에 대한 명확한 정의 X
* ES6 이후
  * 메서드란, 메서드 축약표현으로 정의된 함수만을 의미함
  * 인스턴스를 생성할 수 없는 non-constructor
  * 자신을 바인딩한 객체를 가리키는 내부 슬록 [[HomeObject]]를 가짐



### 화살표 함수

```js
// 함수 정의
const add = (x, y) => x + y;

// 매개변수 선언 -> 매개변수가 한 개인 경우 () 생략 가능, 없는 경우 () 생략 불가
const arrow1 = x => {...};
const arrow2 = () => {...}

// 함수 몸체 정의 -> 하나의 문이라면 {} 생략 가능
const add = (x, y) => x + y;
```

* 일반 함수와의 차이점
  * 인스턴스를 생성할 수 없음
  * 중복된 매개변수 이름을 선언할 수 없음
  * 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않음
    * 따라서 내부에서 참조 시 상위 스코프를 참조
    * 상위 스코프의 this를 참조하는 것을 lexical this라고 함



### Rest 파라미터

* 매개변수 이름 앞에 점 ...을 붙여 정의한 매개변수를 의미함

```js
function foo(param, ...rest){
  console.log(param) // 1
  console.log(rest)  // [2, 3, 4, 5]
}

foo(1, 2, 3, 4, 5)
```



### 매개변수 기본값

* 인수가 전달되지 않은 매개변수의 값은 undefined



## 느낀점

우선 책을 1/2씩 분철을 했었는데, 드디어 딱 첫 번째권을 끝내고 두 번째 책으로 넘어갈 수 있게 되었다! 이 자체만 놓고 뿌듯하겠지만 뭔가 아쉬운 느낌을 지울 수가 없다.

최근 Toss Accelerator라는 멘토링 프로그램 시험을 응시했는데, 거기서 나온 문제들 중 일부가 이 책에서 다뤘던 기본적인 내용과 관련된 것들이 있었다. 그럼에도 불구하고, 책을 개괄적으로 읽어왔다보니 내가 얼마나 많은 부분들을 놓쳐왔는지 다시 한 번 알게 되었다.

책에 쓰여진 한 문장 한 문장도 놓칠 것이 없었구나, 그런데 그것을 놓쳤구나 하는 아쉬움이 깊게 남는다.

남은 한 권은 이전에도 읽어보지 않았던 새로운 영역이다. 조금 더 집중해서, 시간을 확보해두고 읽어서 다음 느낀점을 작성할 때는 이런 아쉬움이 남지 않았기를 바란다.



**Plus!** 궁금한 것이 있다면, 클래스라는 것은 충분히 실무에서 사용할 법한 주제인데, 난 한 번도 Class로 작성된 실무 코드를 본 적도, 써본 적도 없다. 실제로 사용하는 곳이 있을까? 있다면 어떤 환경에서 사용하게 될 지 궁금하다.