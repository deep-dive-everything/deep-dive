# 38 브라우저 렌더링 과정

- 렌더링
    - HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것.

## 1. 요청과 응답

- 필요한 리소스(HTML, CSS, Javascript, image, font등 정적 파일 또는 서버가 동적으로 생성한 데이터)를 서버에 요청하고 서버로부터 응답을 받아 브라우저에 시각적으로 렌더링함.
- 브라우저 주소창으로 요청할 수 있음. 이떄 정적/동적 데이터를 모두 요청 가능.
- html을 파싱하는 중 외부 리소스 로드 태그(link, img, script)를 만나면 HTML 파싱을 중단하고 해당 리소스 파일을 요청함.

## 2. HTTP 1.1과 HTTP 2.0

- HTTP : 웹에서 브라우저와 서버가 통신하기 위한 프로토콜.
- HTTP/1.1은 다중 요청,응답이 불가능하지만 HTTP/2는 다중 요청,응답이 가능함.

## 3.HTML파싱과 DOM 생성

- 문자열로 이루어진 텍스트인 HTML문서를 렌더링하기 위해 브라우저가 이해할수 있는 자료구조(객체)로 변환하여 메모리에 저장해야함.
- 브라우저의 렌더링 엔진은 HTML문서를 파싱하여 DOM(Document Object Model)을 생성함.
- HTML을 문자열로 변환한 뒤 토큰으로 분해함.
- 각 토큰을 객체로 변환하여 노드 생성.
- HTML요소는 중첩 관계를 가짐. 이 중첩관계를 반영하여 트리 자료구조로 구성함.

## 4. CSS파싱과 CSSOM생성

- HTML과 동일한 파싱과정(바이트 → 문자 → 토큰 → 노드 → CSSOM)을 거치며 CSSOM생성.

## 5. 렌더 트리 생성

- DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합됨.
- 렌더트리는 브라우저 화면에 렌더링 되는 노드만으로 구성
- 레이아웃 계산과 페인팅이 재차 실행되는 경우
    - 자바스크립트에 의한 노드 삭제 또는 추가
    - 브라우저 창 리사이징에 의한 뷰포트 크기 변경
    - HTML의 레이아웃에 변경을 발생시키는 스타일 변경.
- 레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 성능에 좋지 않으므로 빈번하게 발생되지 않도록 주의해야함.

## 6. 자바스크립트 파싱과 실행

- 자바스크립트 코드에서 DOM API로 이미 생성된 DOM을 동적으로 조작 가능
- 자바스크립트 파싱과 실행은 자바스크립트 엔진이 처리. 이떄 AST 생성.

## 7. 리플로우와 리페인트

- 리플로우 : 레이아웃 계산을 다시 하는것. 노드 추가/삭제 요소의 크기/위치 변경 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우
- 리페인트 : 재결합된 렌더 트리를 기반으로 다시 페인트 하는 것.
- 이 둘이 반드시 순차적으로 실행되는 것은 아님. 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행

## 8. 자바스크립트 파싱에 의한 HTML파싱 중단

- DOM이 완성되지 않은 상태에서 조작하면 에러가 발생할 수있다.
- 자바스크립트 로딩/파싱/실행으로 인해 HTML요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.

# 39 DOM

## 1. 노드

- HTML요소는 렌더링 엔진에 파싱되어 DOM을 구성하는 요소 노드 객체로 변환됨. 이때 어트리뷰트 요소는 어트리뷰트 노드로, 텍스트 콘텐츠는 텍스트 노드로 변환
- 트리 자료구조 : 부모 노드와 자식 노드로 구성된 계층적 구조를 표현하는 비선형 자료구조

### 1.1 노드 객체의 타입

- 문서 노드
    - DOM트리의 최상위 루트 노드. document 객체를 가리킴
    - 진입점 역할 담당.
- 요소 노드
    - HTML요소의 중첩관계를 통해 정보를 구조화.
- 어트리뷰트 노드
    - 부모노드가 없음. 요소 노드에 접근해야 접근 가능
- 텍스트 노드
    - DOM트리의 최종단. 요소 노드를 부모로 가짐.

## 2. 요소 노드 취득

### 2.1 id를 이용한 요소 노드 취득

- id값이 중복되는 경우 첫 번째 요소 노드를 반환
- 존재하지 않는 경우 null 반환

### 2.4 CSS 선택자를 이용한 요소 노드 취득

- 요소 노드가 여러개인 경우 첫 번쨰 요소 노드만 반환
- 존재하지 않는 경우 null
- 문법에 맞지 않는 경우 DOMException 에러 발생

### 2.5 특정 요소 노드를 취득할 수 있는지 확인

- Element.prototype.matches

### 2.6 HTMLCollection과 NodeList

- DOM API가 여러 개의 결과값을 반환하기 위한 DOM컬렉션 객체.
- 유사배열이면서 이터러블 : for of문으로 순회, 스프레드 문법으로 베열로 변환 가능.
- 노드 상태 변화를 실시간으로 반영하는 살아있는 객체.(live객체)
- HTMLCollection
    - 실시간으로 노드 객체의 상태 변경을 반영하므로 반복문으로 순회하면서 변경할떄 주의 필요.
    - for문을 역방향으로 순회하거나 while문을 사용
    - 스프레드 문법으로배열로 변환하여 순회할것
- NodeList
    - non-live객체
    - childNodes프로퍼티가 반환하는 NodeList 객체는 live객체임.
    - 객체를 배열로 변환하여 사용할 것.

## 3. 노드 탐색

### 3.2 자식 노드 탐색

- Node.prototype.childNodes
    - 자식 노드를 모두 탐색하여 NodeList에 담아 반환
    - 요소노드 뿐 아니라 텍스트 노드도 포함될 수 있음.
- Element.prototype.cildren
    - HTMLCollection에 담아 반환
    - 텍스트노드가 포함되지 않음

## 5. 요소 노드의 텍스트 조작

### 5.1 NodeValue

- 텍스트를 변경하라 요소 노드를 취득한 뒤 취득한 요소 노들의 텍스트 노드를 탐색함.
- 탐색한 텍스트 노드의 nodeValue 프로퍼티를 사용하여 값 변경

### 5.2 textContent

- innerText 프로퍼티는 사용하지 않는 것이 좋음
    - css에 순종적. css에서 hidden 처리된 요소 노드의 텍스트는 반영하지 않음.
    - css를 고려해야하므로 textContent프로퍼티보다 느림.

## 6. DOM 조작

- 성능에 영향을 주므로 성능 최적화를 신경써서 다룰것.

### 6.1 innerHTML

- 요소 노드의 HTML마크업을 취득하거나 변경함.
- 오소노드의 콘텐츠영역에 포함된 모든 HTML마크업을 문자로 반환
- 사용자로 부터 입력받은 데이터를 그대로 innerHTML 프로퍼티에 할당하는 것은 크로스 사이트 스크립팅(XSS) 공격에 취약함.
- 요소 노드의 모든 자식 노드를 제거하고 할당한 HTML마크업 문자열을 파싱하여 DOM변경

### 6.2 insertAdjacentHTML

- 기존 요소에 영향을 주지 않고 추가될 요소만 파싱하여 추가. innerHTML보다 효율적
- HTML마크업 문자열을 파싱하므로 XSS공격에 취약함.

### 6.3 노드 생성과 추가

- 요소 노드 생성
- 텍스트 노드 생성
- 텍스트 노드를 요소 노드의 자식 노드로 추가
- 요소 노드를 DOM에 추가

### 6.4 복수의 노드 생성과 추가

- 노드 생성을 3번 하는 경우 성능저하 발생.
- 컨테이너 요소에 3개의 노드를 자식 요소로 추가하여 한번만 생성하는 방법
- 성능에 유리하지만 불필요한 컨테이너 요소가 추가되므로 바람직하지 않음.
- DocumentFragment 노드 활용 Document.prototype.createDocumentFragment 메서드 사용.

### 6.5 노드 삽입

- 마지막 노드로 추가
    - Node.prototype.appendChild
- 지정한 위치에 노드 삽입
    - Node.prototype.insertBefore(newNode, childNode)
    - 첫번쨰 인수로 전달받은 노드를 두번째 인수로 전달받은 노드 앞에 삽입

### 6.6 노드 이동

- appendChild, insertBefore메서드 사용

### 6.9 노드 삭제

- Node.prototype.removeChild(child)

## 7. 어트리뷰트

### 7.1 어트리뷰트 노드와 attributes 프로퍼티

- 어트리뷰트 이름 = “어트리뷰트 값”
- 공통적으로 사용할 수 있는 것과 특정 요소에서만 사용할 수 있는 것이 있음.
- HTML어트리뷰트당 하나의 어트리뷰트 노드 생성.

### 7.3 HTML어트리뷰트 vs DOM프로퍼티

- HTML 어트리뷰트는 DOM에서 중복관리되지 않음.
- HTML어트리뷰트의 역할은 HTML의 초기 상태를 지정하는것.
- 요소 노드는 상태를 가지고 있음.
- 상태가 변경되는 경우 요소 노드는 초기상태와 최신상태를 모두 관리해야함.
- 요소노드의 초기 상태는 어트리뷰트 노드가 관리하고 요소 노드의 최신 상태는 DOM노드가 관리함.
- DOM프로퍼티
    - 사용자 입력에 의한 상태 변화에 반응하여 언제나 최신 상태 유지

### 7.4 data 어트리뷰트와 dataset프로퍼티

- data-접두사 뒤 이름
- dataset 프로퍼티 : HTML요소의 모든 data어트리뷰트 정보를 제공하는 DOMStingMap객체 반환.
- dataset프로퍼티로 접근.

## 8. 스타일

### 8.1 인라인 스타일 조작

- HTMLElement.prototype.style

### 8.2 클래스 조작

- classList
    - add(…className)
    - remove(…className)
    - item(…index)
    - contains(className)
    - replace(oldclassName, newclassName)
    - toggle(className[,force])
    

# 느낀점

jquery를 많이 써서 익숙한 메서드들이 많아 반가웠습니다. 아무 생각 없이 그떄그떄 사용했던 부분을 기초부터 다지면서 볼 수 있었습니다. 그리고 바닐라로 개발하지 않아도 되는 지금이 되게 편하고 좋다는것을 한번 더 생각하게 되었습니다.
