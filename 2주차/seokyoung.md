## 8장 제어문

> [!NOTE]
> 제어문은 조건에 따라 코드 블록을 실행하거나 반복 실행할 때 사용한다.

### 8.1 블록문

> [!NOTE]
> 블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.

### 8.2 조건문

> [!NOTE]
> 조건문은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.
> 조건식은 불리언 값으로 평가될 수 있는 표현식이다.

#### 8.2.1 if...else 문

- if...else 문은 주어진 조건식의 평가 결과에 따라 실행할 코드 블록을 결정한다.
- 조건식으로 평가 결과가 true일 경우 if 문의 코드블록이 실행되고, fals일 경우 else 문의 코드블록이 실행된다.
- if 문의 조건식은 불리언 값으로 평가되며, 만약 불리언 값이 아닌 값으로 평가되면 암묵적으로 불리언 타입으로 타입 변환된다.
- 조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 els if 문을 사용한다.

```js
// if...else 문
if (조건식) {
  ...
} else {
  ...
}

// else if 문이 있는 if...else 문
if (조건식) {
  ...
} else if (조건식) {
  ...
} else {
  ...
}
```

- 대부분의 if...else 문은 삼항 조건 연산자로 바꿔쓸 수 있다.

```js
const condition = '좋음'
let result

if (condition === '좋음') {
  result = 'good'
} else {
  result = 'bad'
}

result = condition === '좋음' ? 'good' : 'bad' // 'good'
```

#### 8.2.2 switch 문

- switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 case 문으로 실행 흐름을 옮긴다.
- case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.

```js
switch (표현식) {
  case 표현식1:
    // 표현식과 표현식1이 일치하면 실행될 문
    break
  case 표현식2:
    // 표현식과 표현식1이 일치하면 실행될 문
    break
  default:
  // 표현식과 일치하는 case문이 없을 때 실행될 문
}
```

- break 문을 사용하지 않으면 폴스루가 일어날 수 있다.
  - 폴스루: 표현식의 결과가 일치하는 case 문이 있었음에도 switch 문을 탈출하지 않고 이후 모든 case 문과 default 문을 실행하는 경우
- default 문의 실행이 종료되면 switch 문을 빠져나가기 때문에 default 문에는 break 문을 생략하는 것이 일반적이다.
- 만약 if...else 문으로 해결할 수 있다면 if...else 문을 사용하는 편이 좋고, 조건이 너무 많을 때는 switch 문을 사용하는 편이 좋다.

### 8.3 반복문

> [!NOTE]
> 반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다.
> 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다.

### 8.3.1 for 문

- for 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.

```js
for (var i = 0; i < 2; i++) {
  console.log(i)
}
```

### 8.3.2 while 문

- while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 실행하고 거짓이면 실행을 중단한다.

```js
var count = 0

while (count < 3) {
  console.log(count)
  count++
}
```

### 8.3.3 do...while 문

- do...while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다.
- 따라서 코드 블록은 무조건 한 번 이상 실행된다.

```javascript
var count = 0

do {
  console.log(count)
  count++
} while (count < 3)
```

### 8.4 break문

- break 문은 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출할 때 사용한다.
- 레이블 문, 반복문 또는 switch 문의 코드 블록 외에 break 문을 사용하면 Syntaxerror(문법 에러)가 발생한다.
- 레이블 문은 식별자가 붙은 문으로 중첩된 for 문 외부로 탈출할 때 유용하지만 그 밖의 경우에는 일반적으로 권장하지 않는다.

### 8.5 continue 문

- continue 문은 반복문의 코드 블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.
- break 문처럼 반복문을 탈출하지는 않는다.

## 9장 타입 변환과 단축 평가

### 9.1 타입 변환이란?

- 모든 값에 타입이 있는 자바스크립트에서 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** 또는 **타입 캐스팅**이라고 한다.
- 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 **암묵적 타입 변환** 또는 **타입 강제 변환**이라고 한다.
- 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.

### 9.2 암묵적 타입 변환

#### 9.2.1 문자열 타입으로 변환

- 문자열 연결 연산자의 피연산자 중 문자열 타입이 아닌 피연산자는 문자열 타입으로 암묵적 타입 변환

```js
// 숫자 타입
0 + '' // -> "0"
-0 + '' // -> "0"
1 + '' // -> "1"
-1 + '' // -> "-1"
NaN + '' // -> "NaN"
Infinity + '' // -> "Infinity"

// 불리언 타입
true + '' // -> "true"
false + '' // -> "false"

// null 타입
null + '' // 'null'

// undefined 타입
undefined + '' // -> 'undefined'

// 심벌 타입
(Symbol()) + '' // -> TypeError: Cannot convert a Symbol value to a string

// 객체 타입
({}) + '' // -> "[object Object]"
Math + '' // -> "[object Math]"
[] + '' // "
[10,20] + '' // -> "10,20"
(function(){}) + '' // -> "function(){}"
Array + '' // -> "function Array() { [native code] }"
```

#### 9.2.2 숫자 타입으로 변환

- 산술 연산자와 비교 연산자는 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.
- 이때 피연산자를 숫자 타입으로 반환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.

#### 9.2.3 불리언 타입으로 변환

- 조건식의 평가 결과는 불리언 타입으로 암묵적 타입 변환한다.
- 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.
- Falsy 값
  - false
  - undefined
  - null
  - 0, -0
  - NaN
  - ''(빈 문자열)
- Truthy 값
  - Falsy 값 외의 모든 값

### 9.3 명시적 타입 변환

#### 9.3.1 문자열 타입으로 변환

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

#### 9.3.2 숫자 타입으로 변환

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 이용하는 방법 (문자열만 숫자 타입으로 변환 가능)
- 단항 산술 연산자를 이용해 암묵적으로 변환
- \* 산술 연산자를 이용하는 방법

#### 9.3.3 불리언 타입으로 변환

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- ! 부정 논리 연산자를 두 번 사용하는 방법 (!!x)

### 9.4 단축 평가

> [!NOTE]
> 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것

#### 9.4.1 논리 연산자를 사용한 단축 평가

- `&&` 논리곱 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다.
- `||` 논리합 연산자는 둘 중 하나만 true로 평가되어도 true를 반환한다.

```js
true || anything // true
false || anything // anything
true && anything // anything
false && anything // false
```

- 단축 평가가 유용한 상황
  - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
  - 함수 매개변수에 기본값을 설정할 때

#### 9.4.2 옵셔널 체이닝 연산자

- ES11(ECMAScript2020)에서 도입
- 옵셔널 체이닝 연산자 `?.`는 좌항의 피연산자가 null 또는 undefined일 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

```js
var elem = null

var value = elem?.value
console.log(value) // undefined
```

- 옵셔널 체이닝 연산자 `?.`는 좌항의 피연산자가 false로 평가되는 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어간다.

```js
var str = ''

var length = str?.length
console.log(length) // 0
```

#### 9.4.3 null 병합 연산자

- ES11(ECMAScript2020)에서 도입
- null 병합 연산자 `??`는 좌항의 피연산자가 null 또는 undefined일 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

```js
var foo = null ? 'default string'
console.log(foo) // default string
```

- 변수의 기본값을 설정할 때 유용하다.
- null 병합 연산자 `??`는 좌항의 피연산자가 false로 평가되는 Falsy 값이라도 null 또는 undefined가 아니면 좌항의 피연산자를 반환한다.

```js
var foo = '' ? 'default string'
console.log(foo) // ''
```

## 10장 객체 리터럴

### 10.1 객체란?

> [!NOTE]
>
> 객체는 0개 이상의 프로퍼티와 메서드로 구성된 집합체다.
>
> - 프로퍼티는 키와 값으로 구성되며 객체의 상태를 나타내는 값이다.
> - 메서드는 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작이다.

- 자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 "모든 것"이 객체다.
- 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.
- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.

### 10.2 객체 리터럴에 의한 객체 생성

- 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.
- 객체 생성 방법
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스 (ES6)
- 객체 리터럴로 객체 생성하기
  - 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의하여 객체를 생성하는 방법
  - 가장 일반적이고 간단한 방법

```js
var person = {
  name: 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`)
  },
}
```

### 10.3 프로퍼티

- 객체는 프로퍼티의 집합이며, 프로퍼티는 키(key)와 값(value)으로 구성된다.
- 프로퍼티를 나열할 때는 쉼표로 구분한다.
- 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값
  - 프로퍼티 키: 문자열을 포함하는 모든 문자열 또는 심벌 값
  - 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값
- 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.

```js
var person = {
  firstName: 'Ung-mo',
  'last-name': 'Lee',
}

console.log(person) // {firstName: "Ung-mo", last-name: "Lee"}
```

- 문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다.

```js
var obj = {}
var key = 'hello'

obj[key] = 'world'

console.log(obj) // {hello: "world"}
```

### 10.4 메서드

- 프로퍼티가 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부른다.
- 즉, 메서드는 객체에 묶여 있는 함수를 의미한다.
- 메서드 내부에서 사용한 this 키워드는 객체 자신을 가리키는 참조변수다.

```js
var circle = {
  radius: 5, // 프로퍼티
  getDiameter: function () {
    // 메서드
    return 2 * this.radius // circle.radius
  },
}
```

### 10.5 프로퍼티 접근

- 프로퍼티에 접근하는 방법
  - 마침표 프로퍼티 접근 연산자 `.`를 사용하는 **마침표 표기법**
  - 대괄호 프로퍼티 접근 연산자 `[]`를 사용하는 **대괄호 표기법**

```js
var person = {
  name: 'Lee',
}

console.log(person.name) // Lee
console.log(person['name']) // Lee
```

- 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.
- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 ReferenceError는 발생하지 않는다.

### 10.6 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

### 10.7 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

### 10.8 프로퍼티 삭제

- delete 연산자는 객체의 프로퍼티를 삭제한다.
- 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시된다.

### 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

#### 10.9.1 프로퍼티 축약 표현

```js
let x = 1,
  y = 2

const obj = { x, y }

console.log(obj) // {x: 1, y: 2};
```

#### 10.9.2 계산된 프로퍼티 이름

```js
const prefix = 'prop'
let i = 0

const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
}

console.log(obj) // {prop-1: 1, prop-2: 2, prop-3: 3}
```

#### 10.9.3 메서드 축약 표현

```js
const obj = {
  name: 'Lee',
  // 메서드 축약 표현
  sayHi() {
    console.log('hi')
  },
}
```

## 11장 원시 값과 객체의 비교

- 데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유
  - 원시 값은 변경 불가능한 값이고 객체는 변경 가능한 값이다.
  - 원시 값을 변수에 할당하면 변수에는 실제 값이 저장되고 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
  - 원시 값은 값에 의한 전달이고 객체는 참조에 의한 전달이다.
    - 값에 의한 전달: 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달
    - 참조에 의한 전달: 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달

### 11.1 원시 값

#### 11.1.1 변경 불가능한 값

- 원시 값은 변경 불가능한 값, 즉 읽기 전용 값이다.
- 여기에서 변경 불가능하다는 것은 변수가 아니라 값을 말하다는 것을 유의한다.
- 변경이 불가능하다는 원시 값의 특성은 데이터의 신뢰성을 보장한다.
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 있는 방법이 없다.

#### 11.1.2 문자열과 불변성

- 자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공한다.
- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능하다. 이것은 문자열이 생성된 이후에는 변경할 수 없음을 의미한다.

- 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.
  - 유사 배열 객체: 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체
- 문자열은 변경 불가능한 읽기 전용 값이기 때문에 이미 생성된 문자열의 일부 문자를 변경하는 것은 반영되지 않는다.

#### 11.1.3 값에 의한 전달

- 변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?
  - 변수에 원시 값을 갖는 변수를 할당하는 경우 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다.
- 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다.
- "값에 의한 전달"도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다.
- 단, 전달된 메모리를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.
- 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

### 11.2 객체

- 객체는 프로퍼티의 개수가 정해져있지 않으며 동적으로 추가되거나 삭제될 수 있다.
- 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

#### 11.2.1 변경 가능한 값

- 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.
- 원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경가능한 값이다.
- 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 즉, 재할당 없이 프로퍼티를 동적으로 추가할 수 있고, 갱신, 삭제할 수도 있다.
- 얕은 복사와 깊은 복사
  - 얕은 복사: 객체에 한 단계까지만 복사하는 것으로 중첩되어 있는 객체는 고려하지 않는다.
  - 깊은 복사: 객체에 중첩되어 있는 객체까지 모두 복사하는 것

#### 11.2.2 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

```js
var person = {
  name: 'Lee',
}

// 참조 값을 복사 (얕은 복사). copy와 person은 동일한 참조 값을 갖는다.
var copy = person

// copy와 person은 동일한 객체를 참조한다.
console.log(person === copy) // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim'

// person을 통해 객체를 변경한다.
person.address = 'Seoul'

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person) // { name: 'Kim', address: 'Seoul' }
console.log(copy) // { name: 'Kim', address: 'Seoul' }
```

- 결국 "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
- 다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.
- 자바스크립트에는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만이 존재한다고 말할 수 있다.

## 느낀점

오늘 시간에서 공부한 내용 중 단축 평가는 이해하기 어려운 내용은 아닌데 알게 되면 유용한 그런 가성비 좋은(..?)개념이라고 생각합니다.
옵셔널 체이닝 연산자랑 null 병합 연산자가 ECMAScript2020에 도입된 개념인 건 처음 알게 된 사실인데, 생각보다 최신의 개념이라 놀랐습니다 ㅎㅎ

> 자바스크립트에는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만이 존재한다고 말할 수 있다.

얇은 복사, 깊은 복사, 참조에 의한 전달, 값에 의한 전달은 정말 많이 헷갈렸던 개념이었는데요.
코어 자바스크립트에서 엄밀히 말하자면 자바스크립트는 "값에 의한 전달"만 있다는 것을 읽고선 좀 정리가 됐던 기억이 있습니다.
이번 시간에도 다시한번 개념 정리를 했던 면에서 유익한 시간이었다고 생각합니다.

## 공유

```js
function getDayName(dayNumber) {
  let dayName
  switch (dayNumber) {
    case 0:
      dayName = 'Sunday'
      break
    case 1:
      dayName = 'Monday'
      break
    case 2:
      dayName = 'Tuesday'
      break
    case 3:
      dayName = 'Wednesday'
      break
    case 4:
      dayName = 'Thursday'
      break
    case 5:
      dayName = 'Friday'
      break
    case 6:
      dayName = 'Saturday'
      break
    default:
      dayName = 'Invalid day'
  }
  return dayName
}

console.log(getDayName(3)) // Wednesday
console.log(getDayName(7)) // Invalid day
```

위의 switch 문을 아래와 같이 객체와 함수로 분리해 작성했습니다.

```js
const daysOfWeek = {
  0: 'Sunday',
  1: 'Monday',
  2: 'Tuesday',
  3: 'Wednesday',
  4: 'Thursday',
  5: 'Friday',
  6: 'Saturday',
}

function getDayName(dayNumber) {
  return daysOfWeek[dayNumber] || 'Invalid day'
}

console.log(getDayName(3)) // Wednesday
console.log(getDayName(7)) // Invalid day
```

- switch 문의 경우 Wednesday를 찾기 위해 순차적으로 조건을 읽어들인다면, 객체로 작성했을 경우 프로퍼티를 바로 읽어들이기 때문에 가독성 및 성능 상 이점이 있습니다.
- [[Javascript 미세팁] if else 리팩토링 #1 (feat. 객체 + 함수)](https://youtu.be/p0YEviesgRM?si=6nYjUtPGIJzG6CSD)
