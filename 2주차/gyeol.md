# 8장 - 제어문

- 제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.

## 8.1 블록문

- 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부른다.
- 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.
- 블록문은 단독으로 사용할 수도 있지만 일반적으로 제어문이나 함수를 정의할 때 사용한다.
- 문의 끝에는 세미클론을 붙이는 것이 일반적이지만 블록문의 끝에는 세미클론을 붙이지 않는다.
    
    → 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문
    ✔️ 이 부분은 잘 몰랐던 부분이다..!    

    ```jsx
    // 블록문 예시
    {
    	var foo = 10;
    }
    ```
    

## 8.2 조건문

- 주어진 조건식의 평과 결과에 따라 코드 블록(블록문)의 실행을 결정한다.
- 조건식은 불리언 값으로 평가될 수 있는 표현식이다.

### 8.2.1 if … else 문

- 주어진 조건식의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다.
    
    ```jsx
    if(조건식1) {
    	// 조건식1이 참이면 이 코드 블록이 실행
    } else if(조건식2) {
    	// 조건식2가 참이면 이 코드 블록이 실행
    }else {
    	// 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행
    }
    ```
    
- 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.
    
    ```jsx
    var num;
    if (num % 2 === 0) num = '짝수';
    ```
    
- 삼항 조건 연산자는 값으로 평가되는 표현식을 만든다.
    
    → 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다.
    
- if … else 문은 표현식이 아닌 문이다.
    
    → 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.
    
- 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 if … else 문보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다.
- 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if … else문을 사용하는 편이 가독성이 좋다.

### 8.2.2 switch 문

- switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.
- case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.
- switch문의 표현식과 일치하는 case문이 없다면 실행순서는 default 문으로 이동한다.
- default 문은 필수가 아닌 선택사항이다.
    
    ```jsx
    // switch문 예시
    switch (표현식) {
    	case 표현식1:
    		switch문의 표현식과 표현식1이 일치하면 실행될 문;
    		break;
    	case 표현식2:
    		switch문의 표현식과 표현식2이 일치하면 실행될 문;
    		break;	
    	default:
    		switch문의 표현식과 일치하는 case문이 없을 때 실행될 문;
    }
    ```
    
- switch문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.
- if … else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정하고 switch 문은 논리적 참, 거짓보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용한다.
- break 문은 코드 블록에서 탈출하는 역할을 한다. 만약 break 문이 없다면 case 문의 표현식과 일치하지 않더라도 실행 흐름이 다음 case 문으로 연이어 이동한다.
- default 문에는 break 문을 생략하는 것이 일반적이다.
    
    → default 문은 switch 문의 맨 마지막에 위치하므로 default문의 실행이 종료되면 switch 문을 빠져나간다. 따라서 별도로 break문이 필요 없다.
    ✔️ 이렇게 사용하는 걸 알고는 있었지만 디테일한 이유까지는 모르고 사용했다.
    
- **if … else 문으로 해결할 수 있다면 switch 문보다 if … else 문을 사용하는 것이 좋다.**
- **하지만 조건식이 너무 많아서 if … else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch 문을 사용하는 것이 좋다.**

## 8.3 반복문

### 8.3.1 for문

- 조건식이 거짓으로 평가될 때까지 코드블록을 반복 실행
    
    ```jsx
    // for문 예시
    for(변수 선언문 또는 할당문; 조건식; 증감식) {
    	// 조건식이 참인 경우 반복 실행될 문;
    }
    ```
    

### 8.3.2 while 문

- 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.
- for문은 반복 회수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.
- while 문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다. 
만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.
- 조건식의 평가 결과가 언제나 참이면 무한루프가 된다.
    
    ```jsx
    // 무한루프 
    while (true) {
    	...
    }
    ```
    
- 무한루프에서 탈출하기 위해서는 코드 블록 내에 if문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.

### 8.3.3 do … while 문

- 코드 블록을 먼저 실행하고 조건식을 평가한다.
    
    → 코드 블록은 무조건 한 번 이상 실행된다.
    

## break 문

- 레이블 문, 반복문(for, for … in, for … of, while, do while) 또는 switch 문의 코드 블록을 탈출한다.
    
    이외의 경우에 break문을 사용하면 syntaxError(문법 에러) 발생한다.
    
- 레이블문은 식별자가 붙은 문을 뜻한다.
    
    ```jsx
    // 레이블문 예시
    // foo라는 레이블 식별자가 붙은 레이블 문
    foo : console.log('foo');
    ```
    
- 레이블 문은 프로그램의 실행 순서를 제어하는 데 사용한다.
- switch문의 case문과 default 문도 레이블 문이다.
- 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.
    
    ```jsx
    // foo라는 식별자가 붙은 레이블 블록문
    foo : {
    	console.log(1);
    	break foo; // foo 레이블 블록문을 탈출한다.
    	console.log(2);
    }
    
    console.log('Done!');
    ```
    
- 중첩된 for 문의 내부 for문에서 break문을 실행하면 내부 for 문을 탈출하여 외부 for문으로 진입한다. 이 때 내부 for 문이 아닌 외부 for문을 탈출하려면 레이블 문을 사용한다.
    
    ```jsx
    // outer라는 식별자가 붙은 레이블 for문
    outer: for(var i = 0; i < 3; i++) {
    	for(var j = 0; j < 3; j++) {
    		// i + j === 3이면 outer 라는 식별자가 붙은 레이블 for문을 탈출한다.
    		if(i + j === 3) break outer;
    		console.log(`inner [${i}, ${j}]`);
    	}
    }
    
    console.log('Done!');
    ```
    
- 레이블 문은 중첩된 for 문 외부로 탈출할 때 유용하지만 그 밖의 경우에는 일반적으로 권장하지 않는다.
- 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생할 가능성이 높아지기 때문이다.
- switch 문에서도 break문을 사용할 수 있다. 이 경우 break문에 레이블 식별자를 지정하지 않는다. break 문은 반복문을 더 이상 진행하지 않아도 될 때 불필요한 반복을 회피할 수 있다.

## 8.5 continue 문

- continue문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.
- **break 문처럼 반복문을 탈출하지는 않는다.**
    
    ```jsx
    // continue문 예시
    var string = 'hello';
    var serch = 'l';
    var count = 0;
    
    for(var i = 0; i < string.length; i++) {
    	if(string[i] !== search) continue;
    	count++; // continue 문이 실행되면 이 문은 실행되지 않는다.
    }
    
    console.log(count); // 3
    ```
    
- if 문 내에서 실행해야할 코드가 길다면 들여쓰기가 한 단계 깊어지므로 continue 문을 사용하는 편이 가독성이 좋다.

# 9장 - 타입변환과 단축 평가

## 9.1 타입 변환

- 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라한다.
- 개발자의 의도와는 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 암묵적 타입 변환 또는 타입 강제 변환이라 한다.
- 이와 같은 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다. 원시 값은 변경 불가능한 값이다.
- 타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.
- 암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다.
- 자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자의 값을 암묵적 타입 변환해 새로운 타입의 값을 만들어 **단 한 번 사용하고 버린다.**

## 9.2 암묵적 타입 변환

- 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다.
- 암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동변환한다.

### 9.2.1 문자열 타입으로 변환

```jsx
// 예시
1 + '2' // "12"
`1 + 1 = ${1 + 1}` // "1 + 1 = 2"
```

- 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.
- ES6에 도입된 템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다.

### 9.2.2 숫자 타입으로 변환

```jsx
// 예시
1 - '1' // 0
1 * '10' // 10
1 / 'one' // NaN
// 불리언 타입
+true // 1
+false // 0
// null 타입
+null // 0
// undefined 타입
+undefined  // NaN
// symbol 타입 
+Symbol() // TypeError: Cannot convert a Symbol value to a number
// 객체 타입 
+{} // NaN
+[] // 0
+[10, 20] // NaN
+(function(){}) // NaN
```

- 자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.
- 만약 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산자를 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.
- 빈 문자열(’’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다.
- 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다.
  ✔️ 이렇게 디테일한 것까진 몰랐는데 신기하다..!!

### 9.2.3 불리언 타입으로 변환

- 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.
- 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy값(거짓으로 평가되는 값)으로 구분한다.
    
    → 제어문과 조건식과 같이 불리언 값으로 평가되어야할 문맥에서 Truthy 값은 true로, Falsy값은 false로 암묵적 타입 변환된다.
    
    ```jsx
    // Falsy 값들 
    - false
    - undefined
    - null
    - 0, -0
    - NaN
    - ''(빈문자열)
    // Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy값이다.
    - {} // Truthy값 → 좀 신기함..
    - []  // Truthy값 → 좀 신기함..
    ```
    

## 9.3 명시적 타입 변환

- 명시적 타입 변환 방법에는 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 암묵적 타입 변환을 이용하는 방법이 있다.

### 9.3.1 문자열 타입으로 변환

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

### 9.3.2 숫자 타입으로 변환

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
- + 단항 산술 연산자를 이용하는 방법
- * 산술 연산자를 이용하는 방법

### 9.3.3 불리언 타입으로 변환

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- ! 부정 논리 연산자를 두 번 사용하는 방법

## 9.4 단축 평가

### 9.4.1 논리 연산자를 사용한 단축 평가

- 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다.
- 논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.
    
    ```jsx
    'Cat' && 'Dog' // "Dog"
    'Cat' || 'Dog' // "Cat"
    ```
    
- 논리곱(&&) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 또 좌항에서 우항으로 평가가 진행된다.
- 두 번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정하게 된다. 
→ 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자인 문자열 ‘Dog’를 그대로 반환한다.
- 논리합(||) 연산자는 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다. 또 좌항에서 우항으로 평가가 진행된다.
- 첫 번째 피 연산자 ‘Cat’은 Truthy값이므로 true로 평가되며 두 번째 피연산자까지 평가하지 않고도 위 표현식 평가가 가능하다.
    
    → 논리합 연산자는 논리 연산의 결과를 결정한 첫 번째 피연산자인 문자열 ‘Cat’을 그대로 반환한다.
    
- 논리곱 연산자와 논리합 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.
- 이를 단축평가라고 하는데, 단축평가는 표현식을 평가하는 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.
- 단축 평가 규칙
    
    
    | 단축 평가 표현식 | 평가 결과 |
    | --- | --- |
    | true || anything | true  |
    | false || anything | anything |
    | true && anything | anything |
    | false || anything | false |
- 어떤 조건이 Truthy 값일 때 무언가를 해야한다면 논리곱 연산자 표현식으로 if문을 대체할 수 있다.
- 단축 평가를 사용하는 사례
    - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
        
        ```jsx
        var elem = null;
        // elem이 null이나 undefined와 같은 Falsy 값이면 elem으로 평가되고
        // elem이 Truthy값이면 elem.value로 평가된다.
        var value = elem && elem.value; // null
        ```
        
    - 함수 매개면수에 기본 값을 설정할 때
        - 함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다. 이럴 때 단축평가를 이용해서 기본값을 설정할 수 있다.

### 9.4.2 옵셔널 체이닝 연산자

- ES11에서 도입된 옵셔널체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
- 옵셔널 체이닝 연산자가 도입되기 전에는 논리연산자 &&를 사용한 단축 평가를 통해 확인했다.

### 9.4.3 null 병합 연산자

- ES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연사자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다.
- null 병합 연산자는 변수에 기본 값을 설정할 때 유용하다.
- null 병합 연산자가 도입되기 전에는 논리 연산자 ||를 사용한 단축평가를 통해 변수에 기본값을 설정했다.

# 10 - 객체 리터럴

## 10.1 객체란

- 자바스크립트는 개체 기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 모든 것이 객체다!
- 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.
- 원시 타입
    - 단 하나의 값만 나타낸다.
    - 원시타입의 값(원시값)은 변경이 불가능 한  값이다.
- 객체 타입
    - 다양한 타입의 값(원시값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조다.
    - 객체는 변경이 가능한 값이다.
- 객체는 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 키와 값으로 구성된다.
- 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.
- 자바스크립트의 함수는 일급객체이므로 값으로 취급할 수 있는데, 따라서 함수도 프로퍼티 값으로 사용할 수 있다.
    
    → 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부른다.
  ✔️ 여태껏 함수와 메서드가 비슷한 거라고 생각해왔는데 이런 차이가 있었다니..놀랍다!
    
- 프로퍼티 : 객체의 상태를 나타내는 값
- 메서드 : 프로터피(상태 데이터)를 참조하고 조작할 수 있는 동작
- 이처럼 객체는 상태를 나타내는 값(프로퍼티)과 프로퍼티를 참조하고 조작할 수 있는 동작(메서드)를 모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.
