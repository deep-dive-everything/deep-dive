# 8장 - 제어문

- 제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.

## 8.1 블록문

- 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부른다.
- 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.
- 블록문은 단독으로 사용할 수도 있지만 일반적으로 제어문이나 함수를 정의할 때 사용한다.
- 문의 끝에는 세미클론을 붙이는 것이 일반적이지만 블록문의 끝에는 세미클론을 붙이지 않는다.
    
    → 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문
    > ✔️ 이 부분은 잘 몰랐던 부분이다..!    

    ```jsx
    // 블록문 예시
    {
    	var foo = 10;
    }
    ```
    

## 8.2 조건문

- 주어진 조건식의 평과 결과에 따라 코드 블록(블록문)의 실행을 결정한다.
- 조건식은 불리언 값으로 평가될 수 있는 표현식이다.

### 8.2.1 if … else 문

- 주어진 조건식의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다.
    
    ```jsx
    if(조건식1) {
    	// 조건식1이 참이면 이 코드 블록이 실행
    } else if(조건식2) {
    	// 조건식2가 참이면 이 코드 블록이 실행
    }else {
    	// 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행
    }
    ```
    
- 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.
    
    ```jsx
    var num;
    if (num % 2 === 0) num = '짝수';
    ```
    
- 삼항 조건 연산자는 값으로 평가되는 표현식을 만든다.
    
    → 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다.
    
- if … else 문은 표현식이 아닌 문이다.
    
    → 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.
    
- 조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 if … else 문보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다.
- 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if … else문을 사용하는 편이 가독성이 좋다.

### 8.2.2 switch 문

- switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.
- case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.
- switch문의 표현식과 일치하는 case문이 없다면 실행순서는 default 문으로 이동한다.
- default 문은 필수가 아닌 선택사항이다.
    
    ```jsx
    // switch문 예시
    switch (표현식) {
    	case 표현식1:
    		switch문의 표현식과 표현식1이 일치하면 실행될 문;
    		break;
    	case 표현식2:
    		switch문의 표현식과 표현식2이 일치하면 실행될 문;
    		break;	
    	default:
    		switch문의 표현식과 일치하는 case문이 없을 때 실행될 문;
    }
    ```
    
- switch문의 표현식은 불리언 값보다는 문자열이나 숫자 값인 경우가 많다.
- if … else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정하고 switch 문은 논리적 참, 거짓보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용한다.
- break 문은 코드 블록에서 탈출하는 역할을 한다. 만약 break 문이 없다면 case 문의 표현식과 일치하지 않더라도 실행 흐름이 다음 case 문으로 연이어 이동한다.
- default 문에는 break 문을 생략하는 것이 일반적이다.
    
    → default 문은 switch 문의 맨 마지막에 위치하므로 default문의 실행이 종료되면 switch 문을 빠져나간다. 따라서 별도로 break문이 필요 없다.
    > ✔️ 이렇게 사용하는 걸 알고는 있었지만 디테일한 이유까지는 모르고 사용했던 것 같다.
    
- **if … else 문으로 해결할 수 있다면 switch 문보다 if … else 문을 사용하는 것이 좋다.**
- **하지만 조건식이 너무 많아서 if … else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch 문을 사용하는 것이 좋다.**

## 8.3 반복문

### 8.3.1 for문

- 조건식이 거짓으로 평가될 때까지 코드블록을 반복 실행
    
    ```jsx
    // for문 예시
    for(변수 선언문 또는 할당문; 조건식; 증감식) {
    	// 조건식이 참인 경우 반복 실행될 문;
    }
    ```
    

### 8.3.2 while 문

- 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.
- for문은 반복 회수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.
- while 문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다. 
만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별한다.
- 조건식의 평가 결과가 언제나 참이면 무한루프가 된다.
    
    ```jsx
    // 무한루프 
    while (true) {
    	...
    }
    ```
    
- 무한루프에서 탈출하기 위해서는 코드 블록 내에 if문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.

### 8.3.3 do … while 문

- 코드 블록을 먼저 실행하고 조건식을 평가한다.
    
    → 코드 블록은 무조건 한 번 이상 실행된다.
    

## break 문

- 레이블 문, 반복문(for, for … in, for … of, while, do while) 또는 switch 문의 코드 블록을 탈출한다.
    
    이외의 경우에 break문을 사용하면 syntaxError(문법 에러) 발생한다.
    
- 레이블문은 식별자가 붙은 문을 뜻한다.
    
    ```jsx
    // 레이블문 예시
    // foo라는 레이블 식별자가 붙은 레이블 문
    foo : console.log('foo');
    ```
    
- 레이블 문은 프로그램의 실행 순서를 제어하는 데 사용한다.
- switch문의 case문과 default 문도 레이블 문이다.
- 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.
    
    ```jsx
    // foo라는 식별자가 붙은 레이블 블록문
    foo : {
    	console.log(1);
    	break foo; // foo 레이블 블록문을 탈출한다.
    	console.log(2);
    }
    
    console.log('Done!');
    ```
    
- 중첩된 for 문의 내부 for문에서 break문을 실행하면 내부 for 문을 탈출하여 외부 for문으로 진입한다. 이 때 내부 for 문이 아닌 외부 for문을 탈출하려면 레이블 문을 사용한다.
    
    ```jsx
    // outer라는 식별자가 붙은 레이블 for문
    outer: for(var i = 0; i < 3; i++) {
    	for(var j = 0; j < 3; j++) {
    		// i + j === 3이면 outer 라는 식별자가 붙은 레이블 for문을 탈출한다.
    		if(i + j === 3) break outer;
    		console.log(`inner [${i}, ${j}]`);
    	}
    }
    
    console.log('Done!');
    ```
    
- 레이블 문은 중첩된 for 문 외부로 탈출할 때 유용하지만 그 밖의 경우에는 일반적으로 권장하지 않는다.
- 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생할 가능성이 높아지기 때문이다.
- switch 문에서도 break문을 사용할 수 있다. 이 경우 break문에 레이블 식별자를 지정하지 않는다. break 문은 반복문을 더 이상 진행하지 않아도 될 때 불필요한 반복을 회피할 수 있다.

## 8.5 continue 문

- continue문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.
- **break 문처럼 반복문을 탈출하지는 않는다.**
    
    ```jsx
    // continue문 예시
    var string = 'hello';
    var serch = 'l';
    var count = 0;
    
    for(var i = 0; i < string.length; i++) {
    	if(string[i] !== search) continue;
    	count++; // continue 문이 실행되면 이 문은 실행되지 않는다.
    }
    
    console.log(count); // 3
    ```
    
- if 문 내에서 실행해야할 코드가 길다면 들여쓰기가 한 단계 깊어지므로 continue 문을 사용하는 편이 가독성이 좋다.

# 9장 - 타입변환과 단축 평가

## 9.1 타입 변환

- 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라한다.
- 개발자의 의도와는 상관없이 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 암묵적 타입 변환 또는 타입 강제 변환이라 한다.
- 이와 같은 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다. 원시 값은 변경 불가능한 값이다.
- 타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.
- 암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다.
- 자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자의 값을 암묵적 타입 변환해 새로운 타입의 값을 만들어 **단 한 번 사용하고 버린다.**

## 9.2 암묵적 타입 변환

- 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다.
- 암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동변환한다.

### 9.2.1 문자열 타입으로 변환

```jsx
// 예시
1 + '2' // "12"
`1 + 1 = ${1 + 1}` // "1 + 1 = 2"
```

- 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.
- ES6에 도입된 템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다.

### 9.2.2 숫자 타입으로 변환

```jsx
// 예시
1 - '1' // 0
1 * '10' // 10
1 / 'one' // NaN
// 불리언 타입
+true // 1
+false // 0
// null 타입
+null // 0
// undefined 타입
+undefined  // NaN
// symbol 타입 
+Symbol() // TypeError: Cannot convert a Symbol value to a number
// 객체 타입 
+{} // NaN
+[] // 0
+[10, 20] // NaN
+(function(){}) // NaN
```

- 자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.
- 만약 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산자를 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.
- 빈 문자열(’’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다.
- 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다.
 > ✔️ 이렇게 디테일한 것까진 몰랐는데 신기하다..!!

### 9.2.3 불리언 타입으로 변환

- 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.
- 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy값(거짓으로 평가되는 값)으로 구분한다.
    
    → 제어문과 조건식과 같이 불리언 값으로 평가되어야할 문맥에서 Truthy 값은 true로, Falsy값은 false로 암묵적 타입 변환된다.
    
    ```jsx
    // Falsy 값들 
    - false
    - undefined
    - null
    - 0, -0
    - NaN
    - ''(빈문자열)
    // Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy값이다.
    - {} // Truthy값 → 좀 신기함..
    - []  // Truthy값 → 좀 신기함..
    ```
    

## 9.3 명시적 타입 변환

- 명시적 타입 변환 방법에는 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 암묵적 타입 변환을 이용하는 방법이 있다.

### 9.3.1 문자열 타입으로 변환

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

### 9.3.2 숫자 타입으로 변환

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
- + 단항 산술 연산자를 이용하는 방법
- * 산술 연산자를 이용하는 방법

### 9.3.3 불리언 타입으로 변환

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- ! 부정 논리 연산자를 두 번 사용하는 방법

## 9.4 단축 평가

### 9.4.1 논리 연산자를 사용한 단축 평가

- 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다.
- 논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.
    
    ```jsx
    'Cat' && 'Dog' // "Dog"
    'Cat' || 'Dog' // "Cat"
    ```
    
- 논리곱(&&) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 또 좌항에서 우항으로 평가가 진행된다.
- 두 번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정하게 된다. 
→ 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자인 문자열 ‘Dog’를 그대로 반환한다.
- 논리합(||) 연산자는 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다. 또 좌항에서 우항으로 평가가 진행된다.
- 첫 번째 피 연산자 ‘Cat’은 Truthy값이므로 true로 평가되며 두 번째 피연산자까지 평가하지 않고도 위 표현식 평가가 가능하다.
    
    → 논리합 연산자는 논리 연산의 결과를 결정한 첫 번째 피연산자인 문자열 ‘Cat’을 그대로 반환한다.
    
- 논리곱 연산자와 논리합 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.
- 이를 단축평가라고 하는데, 단축평가는 표현식을 평가하는 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.
- 단축 평가 규칙
    
    
    | 단축 평가 표현식 | 평가 결과 |
    | --- | --- |
    | true || anything | true  |
    | false || anything | anything |
    | true && anything | anything |
    | false || anything | false |
- 어떤 조건이 Truthy 값일 때 무언가를 해야한다면 논리곱 연산자 표현식으로 if문을 대체할 수 있다.
- 단축 평가를 사용하는 사례
    - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
        
        ```jsx
        var elem = null;
        // elem이 null이나 undefined와 같은 Falsy 값이면 elem으로 평가되고
        // elem이 Truthy값이면 elem.value로 평가된다.
        var value = elem && elem.value; // null
        ```
        
    - 함수 매개면수에 기본 값을 설정할 때
        - 함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다. 이럴 때 단축평가를 이용해서 기본값을 설정할 수 있다.

### 9.4.2 옵셔널 체이닝 연산자

- ES11에서 도입된 옵셔널체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
- 옵셔널 체이닝 연산자가 도입되기 전에는 논리연산자 &&를 사용한 단축 평가를 통해 확인했다.

### 9.4.3 null 병합 연산자

- ES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연사자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다.
- null 병합 연산자는 변수에 기본 값을 설정할 때 유용하다.
- null 병합 연산자가 도입되기 전에는 논리 연산자 ||를 사용한 단축평가를 통해 변수에 기본값을 설정했다.

# 10 - 객체 리터럴

## 10.1 객체란

- 자바스크립트는 개체 기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 모든 것이 객체다!
- 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.
- 원시 타입
    - 단 하나의 값만 나타낸다.
    - 원시타입의 값(원시값)은 변경이 불가능 한  값이다.
- 객체 타입
    - 다양한 타입의 값(원시값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조다.
    - 객체는 변경이 가능한 값이다.
- 객체는 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 키와 값으로 구성된다.
- 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다.
- 자바스크립트의 함수는 일급객체이므로 값으로 취급할 수 있는데, 따라서 함수도 프로퍼티 값으로 사용할 수 있다.
    
    → 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부른다.
  > ✔️ 여태껏 함수와 메서드가 비슷한 거라고 생각해왔는데 이런 차이가 있었다니..놀랍다!😮😮 
    
- 프로퍼티 : 객체의 상태를 나타내는 값
- 메서드 : 프로터피(상태 데이터)를 참조하고 조작할 수 있는 동작
- 이처럼 객체는 상태를 나타내는 값(프로퍼티)과 프로퍼티를 참조하고 조작할 수 있는 동작(메서드)를 모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.

## 10.2 객체 리터럴에 의한 객체 생성

- 자바스크립트는 프로토타립 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.
    - 객체 리터럴
    - Object 생성자 함수
    - 생성자 함수
    - Object.create 메서드
    - 클래스(ES6)
- 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.
- 객체 리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성한다.
- 객체 리터럴 방식은 객체를 생성하기 위해 클래스를 먼저 정의하고 new 연산자와 함께 생성자를 호출할 필요 없이 숫자 값이나 문자열을 만드는 것처럼 리터럴로 객체를 생성한다.
- 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.

## 10.3 프로퍼티

- 객체는 프로퍼티의 집합이며 프로퍼티는 키과 값으로 구성된다.
    
    ```jsx
    var person = {
    	// 프로퍼티 키는 name, 프로퍼티 값은 'Lee'
    	name: 'Lee',
    	// 프로퍼티 키는 age, 프로퍼티 값은 20
    	age: 20
    }
    ```
    
- 프로퍼티를 나열할 땐 쉼표로 구분한다.
- 프로퍼티키와 프로퍼티 값으로 사용할 수 있는 값
    - 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
    - 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값
- 프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 하지만 식별자 네이밍 규칙이 필수는 아니다. 
→ 그렇지만! 식별자 네이밍 규칙을 따르는 것을 권장한다. 만약 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야한다.

## 10.4 메서드

- 자바스크립트의 함수는 객체(일급객체)로 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다.
- 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다. 메서드는 객체에 묶여있는 함수를 의미한다.

## 10.5 프로퍼티 접근

- 프로퍼티에 접근하는 방법
    - 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법
    - 대괄호 프로퍼티 접근 연산자([…])를 사용하는 대괄호 표기법
    
    ```jsx
    var person = {
    	name: 'Lee'
    }
    // 마침표 표기법에 의한 프로퍼티 접근
    console.log(person.name); // Lee
    // 대괄호 표기법에 의한 프로퍼티 접근
    console.log(person['name']); // Lee
    ```
    
- 대괄호 표기법의 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 **반드시 따옴표로 감싼 문자열**이어야한다.
    
    → 대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진이 식별자로 해석한다.
    > ✔️사소하지만 실수하기 쉬운 부분인 것 같다.

- **객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환**한다. (ReferenceError가 발생하지 않는다!)

# 11 - 원시 값과 객체의 비교

- 원시 타입과 객체 타입의 다른 점
    - **원시 타입의 값(원시값)은 변경 불가능한 값**이다. 이에 비해 **객체 타입의 값(객체)는 변경 가능한 값**이다.
    - **원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제값이 저장**된다. 이에 비해 **객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장**된다.
    - 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달**된다. 이를 **값에 의한 전달**이라 한다.
    객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달**된다. 이를 **참조에 의한 전달**이라한다.

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 혹은 그 메모리 공간을 식별하기 위해 붙인 이름이다.
- 값은 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과이다.
- **변경이 불가능하다는 것은 변수가 아닌 값에 대한 진술이다!**
- **원시값은 변경이 불가능하다 ≠ 변수 값을 변경할 수 없다.**
- **원시값은 변경이 불가능하다 == 원시값 자체를 변경할 수 없다.**
- 원시 값을 할당한 변수에 새로운 원시 값을 재하랃ㅇ하면 메모리 공간에 저장되어있는 재할당 이전의 원시값이 변경되는 게 아니다. 새로운 메모리 공간을 확보하고 재할당한 원시값을 저장한 후 변수는 새롭게 재할당한 원시값을 가리킨다. 이 때 변수가 참조하던 메모리 공간의 주소가 바뀐다.
- **불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**

### 11.1.3 값에 의한 전달

```jsx
// 변수에 변수를 할당하게 되면?
var score = 80;
var copy = score;
console.log(score); // 80
console.log(copy); // 80
// score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다!
var score = 100;
console.log(score); // 100
console.log(copy); // 80
```

- copy = score에서 score는 변수 값 80으로 평가되므로 copy 변수에도 80이 할당되는데 이 때 **새로운 숫자 값 80이 생성되어 할당**된다.
- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy에는 할당되는 변수(score)의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라 한다.
- **값에 의한 전달이라고 표현 하지만 사실 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. → 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 이 때 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.**

## 11.2 객체

- 객체는 원시 값과 다른 방식으로 동작하도록 설계되어있다.

### 11.2.1 변경 가능한 값

- 객체(참조) 타입의 값인 객체는 **변경 가능한 값**이다.
- **객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.**
→ 재할당 없이 프로퍼티를 동적으로 추가, 갱신, 삭제할 수 있다.
- 객체는 **여러 개의 식별자가 하나의 객체를 공유할 수 있다.** 이를 주의해야한다.

### 11.2.2 참조에 의한 전달

```jsx
var person = {
	name: 'Lee'
};
// 참조 값을 복사(얕은 복사)
var copy = person;
```

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달**되는데 이를 **참조에 의한 전달**이라한다.
- 원본 person을 사본 copy에 할당하면 원본 person의 참조값이 복사되어 copy에 저장된다. 이 때 원본 person과 사본 copy는 저장된 메모리 주소만 다를 뿐 동일한 참조값을 갖는다.
    
    → **두 개의 식별자가 하나의 객체를 공유**한다. 이 때 둘 중 하나의 객체를 변경하게 되면 다른 객체에 영향을 준다.
    
- **값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.**

## 💬 느낀점
- 오늘 다룬 내용은 기초지식인 만큼 자주 사용하기 때문에 당연하게 생각하는 부분들이지만 사실 왜 이렇게 사용하는지에 대해 깊은 생각을 해보지 않았던 것 같다. (반성한다!🤨)
- 요즘 회사에서 라이브러리 커스텀을 하면서 프로퍼티에 메서드를 추가하고 수정하는 일을 자주 했는데, 스터디를 통해 개념을 제대로 짚고 넘어갈 수 있어서 좋았다.
- 여진님 발표를 듣다가 문득 변수 같은 경우 개발자가 의도적으로 null이라는 값을 할당했을 때 가비지 컬렉터가 메모리를 회수한다고 알고 있는데 원시값은 사용되지 않을 때 가비지 컬렉터가 어떻게 알고 처리를 하는걸까 라는 것에 대한 궁금증이 생겼다. 이에 대해 질문을 했고 레퍼런스 카운팅이라는 개념에 대한 답변을 들을 수 있었다.
### 자바스크립트에서 메모리를 해제하는 방법
- 자바스크립트에서 메모리를 해제하는 작업은 가비지컬렉터가 하는데 기존에는 레퍼런스 카운팅 알고리즘을 사용하곤 했다.
- 참조 카운팅을 구현이 쉽고 엔진에 부하를 많이 주지 않는 장점이 있지만 순환참조가 있는 경우 메모리 누수가 발생한다는 단점이 있었다.
- 최근 자바스크립트 엔진에서는 Mark & Sweep 알고리즘을 사용한다. 이를 통해 레퍼런스 카운팅의 순환참조 문제를 해결했다.
- 하지만 Mark & Sweep 알고리즘은 최적화 없이 구현할 경우 전체 개체를 탐색하므로 엔진에 영향을 미칠 수 있다.

    출처 : https://sambalim.tistory.com/154    
