### 8장. 제어문

> 제어문을 통해 코드의 실행 흐름을 인위적으로 제어할 수 있다.

- 블록문 = (코드) 블록

  - 0개 이상의 문을 중괄호로 묶은 것
  - 하나의 실행 단위

- 조건문

  - 불리언 값으로 평가될 수 있는 표현식, 평가 결과에 따라 코드 블록의 실행을 결정

    - 조건식이 불리언 값이 아닌 값인 경우 불리언 값으로 강제 변환

  - if...else문

    - if, else 문은 2번 이상 사용 불가능

    - else if 문은 여러 번 사용 가능

    - 삼항 조건 연산자로 변환 가능하다.

      <가독성 기준>

      - 조건에 따라 값을 결정하여 변수에 할당하는 경우 &rarr; 삼항 연산자
      - 실행 내용 복잡한 경우 &rarr; if...else문

  - switch문

    - 표현식 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름 이동
    - 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용
    - default 문 (optional)
      - 표현식과 일치하는 case문이 없는 경우
    - 폴스루 : case 문에 break를 사용하지 않아서 switch문을 탈출하지 않고 모든 case문을 연이어 이동하며 실행하고 마지막으로 default문까지 실행한 상황 &rarr; 이를 이용하는 것도 가능

- 반복문

  - 조건식이 참인 경우 블록 실행 &rarr; 조건식을 재평가하여 참인 경우 블록 실행 &rarr; 조건식이 거짓일 때까지 반복

  - for 문

    - 조건식이 거짓으로 평가될 때까지 코드 블록 반복 실행
    - 반복 횟수가 명확할 때 주로 사용

    ```js
    // 기본 형태
    for(변수 선언문 또는 할당문;조건식;증감식){
    	조건식이 참인 경우 반복 실행될 문;
    }
    
    //무한루프
    for(;;){} 
    
    //중첩 가능
    ```

  - while 문

    - 조건식의 평가 결과가 참이면 코드 블록을 반복 실행
    - 반복 횟수가 불명확할 때 주로 사용
    - 조건식의 평가 결과가 불리언 값이 아니면 강제 변환하여 논리적 참, 거짓을 구별

  - do...while 문

    - 코드 블록을 먼저 실행하고 조건식을 평가 &rarr; 코드 블록 실행 횟수 : 최소 1번

  - break 문

    - 불필요한 반복을 회피할 수 있어 유용 

    - 레이블 문, 반복문, switch 문의 코드 블록 탈출 &rarr; 이외에서 사용 시, SyntaxError 발생

      - 레이블 문 : 식별자가 붙은 문

        - 프로그램 실행 순서 제어

        - switch 문의 case, default 문도 레이블 문 &rarr; *case, default 가 식별자*

        - 레이블 문을 탈출하려면 break문에 레이블 식별자 지정

          ```js
          //중첩된 for문의 내부 for문에서 break 문을 실행하면 내부 for문 탈출
          //외부 for문을 탈출하고 싶은 경우 레이블 문 사용
          
          outer : for(var i=0;i<3;i++){
          	for(var j=0;j<3;j++){
          		if(i+j==3) break outer;//조건 충족 시, outer라는 식별자가 붙은 외부 for문을 탈출
          	}
          }
          ```

    - 반복문, switch 문에서 사용 가능하나 레이블 식별자를 지정하지 않음 &rarr; break; 뿐

  - continue 문

    - 코드 블록 실행을 현 시점에서 중단하고 탈출하지 않고 반복문의 증감식으로 실행 흐름을 이동



### 9장. 타입 변환과 단축 평가

> 자바스크립트의 모든 값은 타입이 있고 다른 타입으로 변환할 수 있다. 개발자의 의도가 들어간 명식적 타입 변화과 엔진에 의해 암묵적으로 변환되는 암묵적 타입 변환을 적절히 혼용하여 예측 가능하고 가독성이 좋은 코드를 작성해야한다.

- 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것 

- 명시적 타입 변환 = 타입 캐스팅 : 개발자가 의도적으로 값의 타입을 변환하는 것

  - 방법 : 표준 빌트인 생성자 함수(String, Number, Boolean)을 new 연산자 없이 호출, 빌트인 메서드 사용

  - 문자열 타입으로 변환

    - String 생성자 함수를 new 연산자 없이 호출
    - Object.prototype.toString 메서드 사용
    - 문자열 연결 연산자 이용

  - 숫자 타입으로 변환

    - Number 생성자 함수를 new 연산자 없이 호출
    - 문자열에만 해당하는 방법 : parseInt, parseFloat 함수를 사용
    - +단항 산술 연산자를 이용하는 방법
    - *산술 연산자를 이용하는 방법

  - 불리언 타입으로 변환

    - Boolean 생성자 함수를 new 연산자 없이 호출

    - ! 부정 논리 연산자를 2번 사용

      ```js
      !!0; // false
      !!'x'; //true
      ```

- 암묵적 타입 변환 = 타입 강제 변환 : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 (문맥을 고려하여) 암묵적으로 타입이 자동 변환하는 것, 새로운 타입의 값을 만들어 한 번 사용하고 버림

  *표현식 : 하나의 값을 산출하는, 값으로 평가될 수 있는 문*

  - 문자열 타입으로 변환

    - +연산자 : 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작하여 모든 피연산자 문자열로 변환

    - 피연산자 이외의 표현식에서도 문자열로의 암묵적 타입 변환 발생

      ```js
      //템플릿 리터럴의 표현식 삽입
      `1 + 1 = ${ 1+ 1}` // "1 + 1 = 2"
      ```

    - 심벌 타입은 암묵적으로 문자열로 타입 변환되지 않음

  - 숫자 타입으로 변환

    - +연산자가 단항 연산자(피연산자가 하나뿐인 연산자)의 경우 피연산자 숫자 타입으로 변환
    - 산술 연산자 (-,*,/) : 모든 피연산자 숫자 타입으로 변환
    - 비교 연산자의 피연산자 숫자 타입으로 변환
    - 빈 문자열, 빈 배열, null, false는 0 으로 true는 1로 변환
    - 객체, 배열(빈 배열 x), undefined는 변환되지 않고 NaN으로 출력
    - 심벌 타입은 암묵적으로 숫자로 타입 변환되지 않음

  - 불리언 타입으로 변환

    - 조건식의 평가 결과를 불리언 타입으로 암문적 타입 변환
    - 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 (참으로 평가되는 값), Falsy 값 (거짓으로 평가되는 값) 으로 구분하여 Truthy 값은 true로 Falsy값은 false로 변환
      - False 값 : false, undefined, null, 0, -0, NaN, ''(빈 문자열)

- 단축 평가 : 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환, 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략

  - 논리합 ( || ) , 논리곱( && ) 연산자 표현식 평가 결과는 2개의 피연산자 중 어느 한쪽으로 평가된다.

    - 논리곱 : 두 개의 피연산자가 모두 true일 때, true 반환, 좌항에서 우항으로 진행
      - 두 번째 피연산자까지 평가가 필요
    - 논리합 : 두 개의 피연산자 중 하나만 true 여도 true 반환, 좌항에서 우항으로 진행
      - 두 번째 피연산자를 평가하지 않아도 평가가 가능한 경우 있음

    ```js
    'Cat' && 'Dog' //Dog
    'Cat' || 'Dog' //Cat
    ```

    - 단축 평가 규칙

      | 단축 평가 표현식    | 평가 결과 |
      | ------------------- | --------- |
      | true \|\| anything  | true      |
      | false \|\| anything | anything  |
      | true && anything    | anything  |
      | false && anything   | false     |

    - if...else 문 대체 가능

      ```js
      var done = true;
      var message = '';
      message = done && '완료'; //if(done) message ='완료'
      done = false;
      message = done || '미완료'; //if(!done) message ='미완료'
      ```

    - 유용한 패턴

      - 객체를 가르키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때

        ```js
        var elm = null;
        var val = elem && elem.value;
        ```

      - 함수 매개변수에 기본값을 설정할 때

        ```js
        function getStringLength(str){
        	str = str||'';
        	return str.length;
        }
        ```

  - 옵셔널 체이닝 연산자 (?.) *ES2020에 추가된 자바스크립트 문법*

    - 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조

      ```js
      var value=elem?.value;
      ```

    - *?. 앞의 평가 대상이 존재하지 않아도 되는 경우에 사용*

    - *읽기, 삭제 가능 쓰기 불가능*

      ```js
      let use = undefined;
      user?.name = 'js'; // undefined = 'js'; => SyntaxError
      ```

  - null 병합 연산자 (??) *ES2020에 추가된 자바스크립트 문법*

    - 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자 반환
    - 변수의 기본값을 설정할 때 유용

    ```js
    var foo = null ?? 'default'; // foo = 'default'
    ```

  - 논리 연산자 vs 옵셔널 체이닝 연산자, null 병합 연산자 : 논리연산자는 Truthy/Falsy에 초점을 두고 옵셔널 체이닝 연산자, null 병합 연산자는 좌항 피연산자의 null 또는 undeined 여부에 초점을 둔다. null 또는 undeined가 아니면 Falsy 값이어도 우항의 프로퍼티를 참조

    ```js
    var foo = '' || 'default'; // foo = 'default';
    var foo = '' ?? 'default'; // foo = '';
    ```

### 10장. 객체

> 자바 스크립트는 객체 기반의 프로그래밍 언어로, 원시 값을 제외한 나머지 값은 모두 객체이다.

- 원시 타입 : 단 하나의 값을 표현, 불변성

- 객체 타입 : 다양한 타입(원시 값 또는 다른 객체)의 값을 하나의 단위로 구성한 복합적 자료구조, 변경 가능

- 0개 이상의 프러퍼티(메서드)로 구성된 집합 &rarr; 객체의 상태를 나타내는 값(프로퍼티)과 프로퍼티를 참조하고 조작할 수 있는 동작(메서드)을 모두 포함하기에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.

  - 프로퍼티 : 객체의 상태를 나타내는 값(data)

    - 키(key)와 값(value)으로 구성

      - 키 : 식별자 역할, 빈 문자열을 포함하는 모든 문자열 또는 심벌 값

        - 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표 사용, 따르는 경우 생략 가능
        - 문자열, 심벌 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열로 변환
        - 연산자, 빈문자열, 예약어 사용 비추천
        - 프로퍼티 키 중복 선언 시, 에러없이 먼저 선언된 프로퍼티를 덮어씀

      - 값 : 자바 스크립트에서 사용할 수 있는 모든 값

        &rarr; 함수도 가능하다. 프로퍼티 값이 함수인 경우 일반 함수와의 구분 위해 메서드라 한다.

        ​	&rarr; 메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작

    - 프로퍼티 나열할 때 쉼표(,)로 구분, 마지막 프로퍼티 쉼표 생략 가능

  ```js
  var person = { // 객체
  	name : 'Lee', // 프로퍼티
  	age : 20, // 프로퍼티
  	//프로퍼티 키 : name, age
  	//프로퍼티 값 : 'Lee', 20
    incrase : function(){ //메서드
      this.age++; 
    }
  };
  ```

  - 프로퍼티 접근

    - 마침표 표기법 

      ```js
      var person={
      	name : 'js'
      };
      
      console.log(person.name)l;
      ```

    - 대괄호 표기법 : 대괄호 프로퍼티 접근 연산자 내부 프로퍼티 키 반드시 따옴표로 감싸야함

      - 키가 숫자로 이루어진 경우에는 따옴표 생략 가능 

      ```js
      console.log(person['name']);
      
      //식별자를 찾지 못한 경우
      console.log(person[name]); // ReferenceError
      
      //객체에 존재하지 않은 프로퍼티에 접근하는 경우
      console.log(person.age); //undefined
      console.log(person['age']); //undefined
      ```

    - 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 경우 반드시 대괄호 표기법을 사용

  - 프로퍼티 값 갱신, 동적 생성, 삭제

    ```js
    var person = {
    	name : 'js'
    };
    
    person.name = 'lee'; // 갱신
    person.age=20; // 동적 생성
    delete person.age // 삭제
    ```

- 프로토타입 기반 객체지향 언어인 자바스크립트의 객체 생성 방법
  - 객체 리터럴
    - 중괄호 {...} 내에 0개 이상의 프로퍼티를 정의한다. (프로퍼티 미정의 시, 빈 객체 생성)
      - 중괄호는 코드 블록을 의미하지 않는다.
        - 코드 블록 중괄호 vs 객체 리터럴 중괄호 : 세미 클론 여부 (코드 블록 x, 객체 리터럴 o)
    - 변수가 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체 생성
    - 문자열, 숫자 값을 생성할 때처럼 객체 생성이 가능하여 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식
    - 객체 생성 동시에 프로퍼티 생성 가능, 객체 생성 이후 프로퍼티 동적으로 추가 가능
    - 객체 리터럴 방식 이외의 객체 생성 방식은 모두 함수 이용
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스 (ES6)

### 11장. 원시 값과 객체의 비교

> 원시 타입과 객체 타입은 근본적으로 다르다.

- 원시 타입

  - 변경 불가능한 값 

    - 변수에 재할당은 가능 (재할당 불가능한 것은 상수) 
    - 변수가 참조하던 메모리 공간의 주소값에 새로운 값을 변경할 수 없다는 의미
    - 새로운 메모리 공간을 확보하여 새로운 값을 저장하고 새로운 메모리 공간 주소를 변수에 참조하게 한다.

    *메모리 공간에 저장하는 이유 : 변환된 데이터를 다시 저장하기 위해서 데이터 크기에 따라 메모리 상 공간을 늘리는 작업보다 새로 공간을 만드는 작업이 효율적이기 때문*

  - 변수에 실제 값이 저장

  - 다른 변수에 할당 시, 값에 의한 전달 &rarr; 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭받지 않음

- 객체 타입

  - 변경 가능한 값
    - 객체를 할당한 변수의 참조값이 변경되지 않음
  - 변수에 참조 값이 저장
  - 다른 변수에 할당 시, 참조에 의한 전달 &rarr; 두 개의 식별자가 하나의 객체를 공유하기에 어느 하나의 객체가 변경하면 서로 영향을 주고 받음.
