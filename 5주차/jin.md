### 19장. 프로토타입

- 자바스크립트는 프로토타입 기반의 객체 지향 프로그래밍 언어이다.

  - 객체 지향 프로그래밍 : 객체(구별을 가능하게 하는 여러가지 속성들을 하나의 단위로 구성)의 집합으로 프로그래밍을 표현
    - 프로퍼티 : 상태 데이터
    - 메서드 : 동작
    - 상속&rarr; 코드를 재사용하여 불필요한 중복을 제거하여 메모리 낭비를 막음

- 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.

  - 프로토타입([[Prototype]]) : 객체의 상위 객체의 역할을 하는 개체로 다른 객체에 공유 프로퍼티와 메서드를 제공 (상속)

    - 모든 객체는 하나의 프로토타입을 가지고 모든 프로토타입은 생성자 함수와 연결되어 있음.
    - `__proto __` 접근자 프로퍼티(객체가 직접 소유하는 프로퍼티가 아닌 상속을 통해 사용 가능)를 통해 프로토타입 객체에 간접적으로 접근 가능
      - 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 하기 때문 (순환 구조 X) 
      - 코드 내에서는 접근자 프로퍼티보다 메서드 사용을 권장

  - 함수 객체의 prototype 프로퍼티 : 생성자 함수가 생성할 인스턴스의 프로토타입

    &rarr; 일반 객체, 생성자 함수로 호출할 수 없는 함수(화살표 함수, ES6 메서드 축약 표현으로 정의한 메서드)는 prototype 프로퍼티를 소유하지 않고 프로토타입도 생성하지 않음.

  - `__proto__` 접근자 프로퍼티 == 함수 객체의 prototype 프로퍼티

  - 모든 프로토타입은 constructor 프로퍼티를 가짐.

  - 리터럴 표기법에 의해 생성된 객체도 프로토타입이 존재하나, 해당 객체의 constructor 프로퍼티가 가리키는 생성자 함수가 객체를 생성한 생성자 함수라고 단정지을 수 없음.

  - | 리터럴 표기법 | 생성자 함수 |      프로토타입      |
    | :-----------: | :---------: | :------------------: |
    |  객체 리터럴  |  `Object`   |  `Object.prototype`  |
    |  함수 리터럴  | `Function`  | `Function.prototype` |
    |  배열 리터럴  |   `Array`   |  `Array.prototype`   |
    | 정규식 리터럴 |  `RegExp`   |  `RegExp.prototype`  |

- 프로토타입의 생성 시점

  - 생성자 함수가 생성되는 시점
  - 프로토타입과 생성자 함수는 항상 쌍으로 존재
  - 사용자 정의 생성자 함수의 경우 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성
  - 빌트인 생성자 함수는 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점(전역 객체가 생성되는 시점)에 프로토타입 생성

- 객체 생성 방식과 프로토타입의 결정

  - 여러 객체 생성 방식(객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create메서드, 클래스)이 있으나 모두 추상연산 OrdinaryObjectCreate에 의해 생성

- 프로토타입 체인 : 상속과 프로퍼티(메서드) 검색을 위한 매커니즘

  - 자바스크립트 엔진은 프로토타입 체인(상속 관계)을 따라 프로퍼티, 메서드 검색
  - *스코프 체인은 식별자 검색을 위한 메커니즘

- 오버라이딩 : 프로토타입에 메서드가 존재할 때, 인스턴스에 같은 메서드를 추가해 재정의하여 사용하는 방식

- 프로퍼티 섀도잉 : 인스턴스에서 오버라이딩을 통해 사용하면 프로토타입 메서드가 가려지는 현상

- ```js
  const Person = (function () {
    // 생성자 함수
    function Person(name) {
      this.name = name;
    }
  
    // 프로토타입 메서드
    Person.prototype.sayHello = function () {
      console.log(`Hi! My name is ${this.name}`);
    };
  
    // 생성자 함수를 반환
    return Person;
  }());
  
  const me = new Person('jin');
  
  // 인스턴스 메서드 (오버라이딩)
  me.sayHello = function () {
    console.log(`Hey! My name is ${this.name}`);
  };
  
  // 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.(프로퍼티 섀도잉)
  me.sayHello(); // Hey! My name is jin
  
  // 인스턴스 메서드를 삭제한다.
  delete me.sayHello;
  // 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출된다.
  me.sayHello(); // Hi! My name is jin
  
  // 프로토타입 메서드 변경
  Person.prototype.sayHello = function () {
    console.log(`Hey! My name is ${this.name}`);
  };
  me.sayHello(); // Hey! My name is jin
  
  // 프로토타입 메서드 삭제
  delete Person.prototype.sayHello;
  me.sayHello(); // TypeError: me.sayHello is not a function
  ```

  

- 프로토타입의 교체 : 부모 객체 프로토타입을 동적으로 변경 가능, 객체 간 상속 관계를 동적으로 변경 가능

  - 생성자 함수에 의한 프로토타입 교체
    - prototype 프로퍼티 통해 프로토타입 교체 시, constructor 프로퍼티와 생성자 함수간의 연결이 파괴되어 교체 후 constructor 검색 시, Object가 나옴
    - prototype 프로퍼티가 교체된 프로토타입을 가르킴
  - 인스턴스에 의한 프로토타입 교체
    - `__proto__`접근자 프로퍼티 통해 프로토타입에 접근하여 교체하는 방법은 이미 생성된 객체의 프로토타입을 교체하는 것이고 교체한 객체에 constructor 프로퍼티가 없어 생성자 함수 간의 연결이 파괴되어 생성자 함수 간 연결이 파괴되어 교체 후 constructor 검색 시, Object가 나옴
    - prototype 프로퍼티가 교체된 프로토타입을 가르키지 않음
  - 위 작업을 통해 상속 관계를 변경하는 것은 번거롭기에 클래스를 사용해 구현하는 것이 나음

- instanceof 연산자

  - 객체 instanceof 생성자 함수
    - 생성자 함수의 프로토타입에 바인딩된 객체가 좌측 객체의 프로토타입 체인 상 존재하면 true, 존재하지 않으면 false
    - constructor 프로퍼티와 생성자 함수간의 연결이 파괴되어도 instance연상에는 영향 X 

- 직접 상속

  - Object.create 메서드에 의한 직접 상속
    - 명시적으로 프로토타입 지정하여 새로운 객체 생성
    - 장점
      - new 연산자 없이 객체 생성
      - 프로토타입 지정하면서 객체 생성
      - 객체 리터럴에 의해 생성된 객체도 상속 가능
  - 객체 리터럴 내부에서 `__proto__`에 의한 직접 상속

- 정적 프로퍼티/메서드 : 인스턴스를 생성하지 않아고 참조, 호출 가능한 프로퍼티/메서드

- 프로퍼티 존재 확인

  - in 연산자
  - Object.prototype.hasOwnProperty 메서드

- 프로퍼티 열거

  - for...in 문
    - 고유 프로퍼티와 상속받은 프로퍼티까지 열거
  - Object.keys/values/entries 메서드
    - 고유 프로퍼티만 열거

### 20장. strict mode

> 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 문제를 일으킬 수 있는 코드에 대한 명시적인 에러를 발생

- 전역의 선두, 함수 몸체의 선두에 'use strict'; 추가하여 적용
  - 라이브러리가 non-strict mode 인 경우 strict mode와 혼용해서 사용하면 오류가 발생할 수 있으므로 전역 사용은 바람지하지 않음.
  - 함수 단위로 적용 시, 일일이 적용하는데 번거로움
- 즉시 실행 함수 선두에 적용하는 것이 바람직함.
- 발생시키는 에러
  - 암묵적 전역
    - 선언하지 않은 변수 참조 시, 레퍼런스 에러
  - 변수, 함수, 매개변수의 삭제(delete)
    - delete 연산자로 삭제 시 Syntax 에러
  - 매개변수 이름의 중복
    - Syntax 에러
  - with문의 사용
    - Syntax 에러
- 일반 함수 this에 undefined 바인딩
- 매개변수에 전달되 인수를 재할당하여 변경해서 arguments 객체에 미반영

### 느낀점

비슷한 단어들이 나오지만 내용은 다르기에 많이 헷갈렸다. 사용보다 학습을 목적으로 반복적으로 내용을 살펴봐야겠다.
