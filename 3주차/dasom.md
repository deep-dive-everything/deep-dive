# Morden JavaScript Deep Dive

Dasom, 2024.06.02

## 12장 함수

* 함수: "입력"을 받아 "출력"하는 일련의 과정 / 일련의 과정을 문으로 구현하고 코드 블록으로 감싸 하나의 실행단위로 정의한 것

* 함수 생성방법

  ```js
  // 함수 정의 (함수 선언문)
  function add(x, y){
    return x + y;
  }
  ```

* 함수 사용 이유: 코드 재사용성 ↑

* 함수 리터럴

  > **"리터럴"**이란?
  >
  > "리터럴"은 프로그래밍 언어에서 고정된 값을 의미합니다. 객체 리터럴, 함수 리터럴 등에서 "리터럴"이라는 용어가 사용될 때, 이는 해당 _데이터 타입의 값을 정의하는 구문_을 의미합니다. - by. ChatGPT

  * 함수 리터럴 구성 요소: function 키워드, 함수 이름, 매개 변수, 함수 몸체

* 함수의 정의 방법

  * 함수 선언문 (함수 이름의 위치에 주목!)

    * 함수 이름을 생략할 수 없음
    * 표현식이 아닌 문 (∵함수 선언문은 실행하면 완료 값이 뜸.)
      * 따라서 변수에 할당할 수 없다.

    > 함수 선언문이 변수에 할당되는 것처럼 보이는 이유?
    >
    > 자바스크립트 엔진이
    >
    > 1) 함수 리터럴을 표현식이 아닌 문인 _함수 선언문_으로 해석하는 경우와
    >
    > 2) 표현식인 문인 _함수 리터럴 표현식_으로 해석하는 경우가 있기 때문

  ```js
  function add(x, y){
    return x + y;
  }
  ```

  * 함수 표현식 (함수 이름 생략, 함수를 변수에 할당)

    * 함수는 **객체 타입**의 값
    * 함수 이름 생략 가능 

    ⚠️ 함수 이름을 표기했다면? -> 함수 몸체 내부에서만 유효한 식별자이기 때문에 함수 이름으로 함수 호출 불가

    * 표현식인 문

  ```js
  const add = function(x, y) {
    retrun x + y;
  }
  ```

  * Function 생성자 함수
    * 함수 선언문이나 함수 표현식으로 생성한 함수와 동일하게 동작하지 않음 (추후 클로저와 함께 내용 등장 예정)

  ```js
  const add = new Function('x', 'y', 'return x+y');
  ```

  * 화살표 함수(ES6)
    * 화살표 함수는 항상 익명 함수로 정의함

  ```js
  const add = (x, y) => x + y;		
  ```

* 함수 호이스팅

  * 함수 선언문으로 정의한 함수는 런타임 이전에 자바스크립트 엔진에 의해 실행

    > var 와 달리 런타임 이전에 **함수 객체**가 먼저 생성되기 때문에, 선언문 이전에 호출해서 사용 가능
    >
    > 따라서 함수 표현식의 사용을 권장

  * 함수 표현식은 함수 호이스팅이 아닌 변수 호이스팅이 발생 (undefined)



* 함수 호출

  * 매개변수와 인수

    * 인수가 부족할 경우 매개변수의 값은 undefined
    * 초과된 인수는 무시

    * 최대 개수가 명시적으로 제한되어 있지는 않지만 3개 이하 사용 권장

  > 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급됨
  >
  > 따라서, 값에 의한 전달, 참조에 의한 전달 방식을 따름

  * 반환문
    * return 뒤에 작성된 문은 무시
    * return 뒤에 표현식이 없다면 undefined 반환
    * 반환문 생략시 암묵적 undefined 반환
    * 반환문은 함수 몸체 내부에서만 사용 가능



* 함수의 형태

  * 즉시 실행 함수

    * 그룹 연산자 (...)로 감싸야 함
    * 재호출 불가

  * 재귀 함수

    * 자기 자신을 호출하는 함수
    * 반복문보다 재귀함수가 더 직관적일 때에 한해 사용 권장

    ```js
    // 예시: 팩토리얼 구현
    function factorial(n) {
      // 재귀 탈출 조건
      if (n <= 1) return 1;
      return n * factorial(n-1);
    }
    ```

  * 중첩 함수

    * 함수 내부에 정의된 함수

  * 콜백 함수

    * 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
    * 콜백 함수를 전달받은 함수는 고차함수라고 함

  * 순수 함수

    * 외부 상태에 의존하지 않고 변경하지도 않는, 부수 효과가 없는 함수

    ```js
    function increase(n) {
      return ++n; 
    }
    ```

  * 비순수 함수

    * 부수 효과가 있는 함수

    ```js
    var count = 0;
    function increase() {
      ++count;
    }
    ```

    



## 13장 스코프

* 스코프: 식별자가 유효한 범위

* 스코프의 종류

  * 전역: 코드의 가장 바깥 영역
  * 지역: 함수 몸체 내부

* 스코프 체인: 스코프가 함수에 중첩에 의해 계층적 구조를 가짐

  * 탐색 방향: 변수를 참조하는 스코프 -> 상위 스코프

* 함수 레벨 스코프

  * 대부분의 코드 블록은 블록 레벨 스코프를 가짐

  * 하지만 var로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정

    -> 따라서 if문, for문 등 안에서 사용된 var는 예상치 못한 값의 재할당을 일으킬 수 있음

* 렉시컬 스코프

  * 렉시컬 스코프 == 정적 스코프: 함수를 어디서 **정의**했는지에 따라 상위 스코프를 결정



## 14장 전역 변수의 문제점

* 변수의 생명 주기

  * 지역 변수: 함수가 종료되면 소멸
  * 전역 변수: 마지막 문이 되어 더 이상 실행할 문이 없을 때 종료

* 전역 변수의 문제점

  * 암묵적 결합: 모든 코드가 전역 변수를 참조하고 변경하는 것을 허용
  * 긴 생명 주기
  * 스코프 체인 상에서 종점에 존재: 검색 속도가 가장 느림
  * 네임스페이스 오염: 파일 간 동일한 이름 사용 시 예상치 못한 에러 발생 가능

* 전역 변수 사용 억제법

  * 즉시 실행 함수

    생각 덧붙임) var의 사용을 지양하는 현재는, 즉시 실행 함수로 모든 코드를 감싸는 것 대신 let이나 const를 사용하는 것이 더 맞는 방법일 것 같다.

  * 네임스페이스 객체

    ```js
    var MYAPP = {}; // 전역 네임스페이스 객체
    MYAPP.name = 'Lee';
    ```

  * 모듈 패턴	

    * 클래스를 모방하여 관련 변수와 함수를 즉시 실행 함수로 감쌈

  >  현재 사용 하는 **ES6+** 모듈은 파일 자체의 독자적 모듈 스코프를 제공하여,
  >
  > **전역 변수를 사용할 수 없다.**

  

## 15장 let, const 키워드와 블록 레벨 스코프

* var의 문제점
  * 변수 중복 선언 허용
  * 함수 레벨 스코프
  * 변수 호이스팅

=> var의 문제점을 보완하기 위해 나온 두 가지 변수 선언 키워드 `let`, `const`

* let의 특징
  * 변수 중복 선언 금지
  * 블록 레벨 스코프
  * 변수 호이스팅
* const
  * 선언과 동시에 초기화
  * 재할당 금지
  * 상수
  * const로 선언한 변수에 객체를 할당한 경우
    * 객체는 재할당 없이도 직접 변경이 가능
    * 따라서, 객체 값을 변경할 수 있음
    * 즉, const는 재할당을 금지할 뿐 불변을 의미하는 것은 아님



## 느낀점

*  함수 선언문이 변수에 할당되는 것처럼 보이는 이유에 대해 명확히 이해하지 못했다. 스터디 발표시간을 통해 제대로 짚고 넘어가고 싶다. 



