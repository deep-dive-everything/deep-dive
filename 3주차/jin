### 12장. 함수

> 함수는 코드의 재사용 측면에서 매우 유용하다. &rarr; 편의성, 신뢰성 증가
>
> 이상적인 함수는 한가지 일만 해야 한다.

- 함수 : 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의
  - 매개 변수(인자) : 함수 내부로 입력을 전달받는 변수, 함수 몸체 외부에서 참조 불가능
  - 인수 : 입력, 개수와 타입에 제한이 없음
  - 반환값 : 출력, 반환문 return은 함수 묨체 내부에서만 사용 가능
  - 함수는 객체이지만, 일반 객체와 호출여부에 차이가 있다. 일반 객체는 호출 불가능, 함수는 호출 가능
  - 일급 객체 : 함수를 값처럼 자유롭게 사용 가능 ( 변수 할당 가능, 프로퍼티 값 가능, 배열 요소 가능 등)
  - 매개변후와 인수의 개수가 일치하는지 확인하지 않는다. &rarr; 확인하는 별도 처리 필요
- 함수 정의
  - 함수 선언문
    - 함수 리터럴과 형태 동일
      - 함수 선언문 : 함수 이름 생략 불가능, 호출 가능
      - 함수 리터럴 표현식 : 함수 이름 생략 가능, 호출 불가능
      - 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출
    - 표현식이 아닌 문 &rarr; 변수 할당 불가능
  - 함수 표현식
    - 함수 리터럴로 생성한 함수 객체를 변수에 할당
  - Function 생성자 함수
    - 일반적이지 않고 바람직하지 않은 방식
  - 화살표 함수
    - function 키워드 대신 화살표 기호를 사용해 간략한 방법으로 함수 선언 가능 

- 호이스팅 &rarr; 함수 표현식 이용 권장

  - 함수 선언문 : 함수 호이스팅 발생
    - 선언문 이전에 함수 참조, 호출 가능
    - 런타임에 함수 객체 이미 생성, 할당까지 완료
  - 함수 표현식 : 변수 호이스팅 발생
    - 함수 표현식 이후에 참조, 호출해야 한다.
    - 할당문이 실행되는 시점에 함수 객체가 된다.

- 참조에 의한 전달과 외부 상태의 변경

  - 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손된다.

    &rarr; 객체를 불변 객체로 만들어 사용 (복사복 생성 비용이 들지만 원시값처럼 사용 가능)

- 즉시 실행 함수 : 함수 정의와 동시에 즉시 호출되는 함수(그룹 연산자로 감싸는 형태), 단 한번만 호출 가능

- 재귀 함수 : 자기 자신을 호출하는 함수

- 중첩 함수(내부 함수) : 함수 내부에 정의된 함수

  - 위부 함수 : 중첨 함수를 포함하는 함수

- 콜백 함수 : 매개변수를 통해 다른 함수의 내부로 전달되는 함수

  - 고차 함수 : 콜백함수를 전달받은 함수

- 순수 함수 : 부수 효과가 없는 함수

- 비순수 함수 : 부수 효과가 있는 함수

### 13장. 스코프

- 스코프 : 식별자가 유효한 범위
  - 자바스크립트 엔진이 식별자 검색 시, 사용하는 규칙
  - 선언된 위치에 따라 스코프 결정 
    - 전역 : 어디서나 참조 가능
    - 지역 : 함수 몸체 내부, 지역 스코프와 하위 스코프에서 유효
- 스코프 체인 : 함수의 중첩에 의해 계층적 구조를 가지고 계층적으로 연결된 것
  - 자바스크립트 엔진은 스코프 체인을 통해 참조하는 코드의 스코프에서 시작하여 상위 스코프로 이동하며 변수를 검색 &rarr; 하위 스코프에서 상위 스코프 변수 참조 가능, 상위 스코프에서 하위 스코프 변수 참조 불가능
  - 물리적 실체로 본재
- 렉시컬 스코프 (정적 스코프) : 함수를 어디서 정의했는지에 따라 함수의 상위 스코프(자신이 정의된 스코프)를 결정

​	

### 14장. 전역 변수의 문제점

> 변수의 스코프는 좁을수록 좋다.

- 변수의 생명 주기 : 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점 &rarr; 스코프도 마찬가지

- 지역 변수의 생명 주기 = 함수의 생명 주기

- 전역 변수의 생명 주기 = 전역 객체의 생명 주기

  &rarr; 어디서나 참조하고 변경할 수 있어서 가독성이 나쁘고 의도치 않은 상태 변경 위험성 높음

  &rarr; 메모리 리소스 오랜 기간 소비

  &rarr; 스코프 종점에 존재하여 검색 속도가 가장 느림

  &rarr; 네임 스페이스 오염

- 전역 변수 사용 억제 

  - 즉시 실행 함수
  - 네임 스페이스 객체
  - 모듈 패턴
  - ES6 모듈 

### 15장. let, const 키워드와 블록 레벨 스코프

- var 키워드 사용의 문제점
  - 변수 중복 선언 허용
  - 함수 레벨 스코프 &rarr; 함수 코드 블록만을 지역 스코프로 인정하여 함수 외부, 코드 블록 내에 선언해도 모두 전역 변수화
  - 변수 호이스팅 &rarr; 가독성 저하, 오류 발생 가능성 높임
- let
  - 변수 중복 선언 금지
  - 블록 레벨 스코프 : 모든 코드 블록을 지역 스코프로 인정
  - 변수 호이스팅 시 , 오류 발생
    - 선언 단계와 초기화 단계 분리 &rarr; 초기화 단계 이전 변수 접근 시, TDZ에 존재하여 접근 불가능
  - 재할당 가능
- const
  - 선언과 초기화 동시에 발생
  - 재할당 불그낭
  - 상수(재할당이 금지된 변수) 표현 시, 사용
  - 객체의 경우 값 변경 가능

