## 48장 모듈
### 48.1 모듈의 일반적 의미
- 모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각이다
- 모듈은 자신만의 파일 스코프를 가질 수 있어야 한다.
- 모듈은 기본적으로 비공개이지만 재사용을 위해 명시적으로 선택적 공개가 가능하다. 이를 export라 한다.
- 모듈은 다른 모듈에서 재사용할 수 있도록 export한 자산을 import하여 사용할 수 있다.

### 48.2 자바스크립트와 모듈
- 자바스크립트는 파일 스코프와 import, export를 지원하지 않았다.
- 클라이언트 사이드 자바스크립트는 script 태그를 사용하여 외부의 자바스크립트 파일을 로드할 수는 있지만 파일마다 독립적인 파일 스코프를 갖지 않는다.
- 따라서 하나의 전역을 공유하고 분리된 자바스크립트 파일들의 전역 변수가 중복되는 등의 문제가 발생할 수 있다.
- 이러한 문제를 해결하기 위해 CommonJS, AMD가 등장했다.
- 자바스크립트 런타임 환경 NodeJS는 CommonJS를 채택하여 모듈 시스템을 지원한다.

### 48.3 ES6 모듈(ESM)
- ES6에서는 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 도입했다.
- IE를 제외한 대부분의 브라우저에서 ES6 모듈을 사용할 수 있다.
- script 태그에 `type="module"` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.
- 일반적인 자바스크립트 파일이 아닌 ESM임을 명확히 하기 위해 ESM의 파일 확장자는 mjs를 사용할 것을 권장한다.

#### 48.3.1 모듈 스코프
- ESM은 독자적인 모듈 스코프를 갖는다.
- ESM이 아닌 일반적인 자바스크립트 파일은 script 태그로 분리해서 로드해도 독자적인 모듈 스코프를 갖지 않는다.
- ESM은 파일별로 독립적인 모듈 스코프를 갖는다.
- 모듈 내에서 선언한 식별자는 모듈 외부에서 참조할 수 없다.

#### 48.3.2 export
- 모듈은 export 키워드를 사용하여 공개할 자산을 선택적으로 공개할 수 있다.
- 선언문 앞에 매번 export 키워드를 붙이는 것이 번거롭다면 export할 대상을 하나의 객체로 구성하여 한번에 export할 수도 있다.

#### 48.3.3 import
- 모듈 사용자는 import 키워드를 사용하여 모듈이 공개한 자산을 선택하여 자신의 스코프로 불러들일 수 있다.
- 다른 모듈이 export한 식별자 이름으로 import해야 하며 ESM의 경우 파일 확장자를 생략할 수 없다.
- 모듈에서 하나의 값만 export 한다면 default 키워드를 사용할 수 잇다. default 키워드를 사용하는 경우 기본적으로 이름 없이 하나의 값을 Export한다.
- default 키워드를 사용하는 경우 var, let, const 키워드는 사용할 수 없다.

## 49장 Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축
- IE11을 제외한 대부분의 브라우저는 ES6+의 최신 ECMAScript 사양을 지원한다.
- 하지만 IE를 포함한 구형 브라우저에서 문제 없이 코드를 동작시키기 위한 개발 환경을 구축해야 한다.
- 또한 대부분의 프로젝트가 모듈을 사용하므로 모듈 로더도 필요하다.
- 하지만 다음과 같은 이유로 아직까지는 ESM보다는 별도의 모듈 로더를 사용하는 것이 일반적이다.
  - IE를 포함한 구형 브라우저는 ESM을 지원하지 않는다.
  - ESM을 사용하더라도 트랜스파일링이나 번들링이 필요하다.
  - ESM이 아직 지원하지 않는 기능이 있고 이를 해결하고 있지만 몇 가지 이슈가 존재한다.

## 49.1 Babel
다음 예제에서는 ES6의 화살표 함수와 ES7의 지수 연산자를 사용하고 있다.
```javascript
[1, 2, 3].map((n) => n ** 2);
```

IE 같은 구형 브라우저에서는 두가지를 지원하지 않을 수 있다. 이때 Babel을 사용하면 ES6+의 최신 ECMAScript 사양으로 작성된 코드를 구형 브라우저에서도 동작할 수 있는 코드로 변환할 수 있다.
```javascript
'use strict';

[1, 2, 3].map(function (n) {
  return Math.pow(n, 2);
});
```

### 실습! 이건 프로젝트 만들어서 로컬에서 진행했습니다.

#### 49.1.5 브라우저에서 모듈 로딩 테스트
- 예제의 모듈 기능은 Node.js 환경에서 동작한 것이고 Babel이 모듈을 트랜스파일링한것도 Node.js가 기본 지원하는 CommonJS 방식의 모듈 로딩 시스템에 따른 것이다.
- 브라우저는 CommonJS 방식의 require 함수를 지원하지 않으므로 트랜스파일링된 결과를 그대로 브라우저에서 실행하면 에러가 발생한다.
- index.html 파일을 작성하여 자바스크립트 파일을 브라우저에서 실행하면 아래와 같은 에러가 발생한다.
```text
uncaught ReferenceError: exports is not defined at lib.js:3
main.js:3 uncaught ReferenceError: require is not defined
```
- 브라우저의 ESM을 사용하도록 babel을 사용할 수도 있으나 앞서 설명한 것과 같이 ESM을 사용하는 것은 문제가 있다.

### 49.2 Webpack
- Webpack은 의존 관계에 있는 자바스크립트, CSS, 이미지 등의 리소스들을 하나의 파일로 번들링하는 모듈 번들러다.
- Webpack을 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈 로더가 필요없다.
- 그리고 여러 개의 자바스크립트 파일을 하나로 번들링하므로 script 태그로 여러 개의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다.

#### 실습! 이건 아까 만든 프로젝트에서 추가 진행했습니다.

## 느낀점
몇달간의 대장정이 끝났군요. 마지막이라니 아쉽기도 하고 뿌듯하기도 합니다.
아직 반복해서 봐야할 부분이 많긴 하지만 모르는 개념이 있을 때 어디에서 찾아보면 될지를 알 것 같아 그것만으로도 많은 걸 얻은 것 같습니다.
한분도 빠짐없이 열심히 참여해주시고 좋은 내용들 공유 많이해주셔서 배운 게 정말 많았습니다. 감사했습니다!