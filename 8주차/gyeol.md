# 27장 - 배열

## 27.1 배열이란?

- 배열은 객체지만 일반 객체와는 구분되는 특징이 있음
    
    
    | 구분 | 객체 | 배열 |
    | --- | --- | --- |
    | 구조 | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
    | 값의 참조 | 프로퍼티 키 | 인덱스 |
    | 값의 순서 | ❌ | ⭕ |
    | length 프로퍼티 | ❌ | ⭕ |
- 일반 객체와 배열을 구분하는 가장 큰 차이는 `값의 순서`와 `length 프로퍼티`
- 인덱스로 표현되는 값의 순서와 length 프로퍼티를 갖는 배열은 반복문을 통해 순차적으로 값에 접근하기 적합한 자료구조

## 27.2 자바스크립트 배열은 배열이 아니다

- 자료구조에서의 배열은 `밀집 배열`
- 밀집 배열
    - 배열의 요소는 하나의 데이터 타입으로 통일되어 있고 서로 연속적으로 인접
- 자바스크립트의 배열은 `희소 배열`
- 희소 배열
    - 배열의 요소를 위한 메모리 공간 각각은 동일한 크기를 갖지 않아도 됨
    - 배열의 요소가 연속적으로 이어져 있지 않음
- **자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체**
- 자바스크립트 배열은 해시 테이블로 구현된 객체
    - 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인 면에서 느림
    - 요소 삽입 or 삭제의 경우 일반적인 배열보다 성능이 빠름

## 27.3  length 프로퍼티와 희소 배열

- 일반적인 배열의 length는 배열 요소의 개수(배열의 길이)와 항상 일치
- 희소 배열은 length와 배열 요소의 개수가 일치하지 않음
    
    → 희소 배열의 length는 희소 배열의 실제 요소 개수보다 항상 큼 
    
- 자바스크립트는 문법적으로 희소배열을 허용하지만 사용하지 않는 것이 좋음
- 배열은 같은 타입의 요소를 연속적으로 위치시켜야함

## 27.4 배열 생성

### 27.4.1 배열 리터럴

- 가장 일반적이고 간편한 배열 생성 방식
- 0개 이상의 요소를 쉼표로 구분하여 대괄호로 묶음
- 객체 리터럴과 달리 프로퍼티 키가 없고 값만 존재
    
    ```jsx
    const arr = [1,2,3];
    console.log(arr.length); // 3
    ```
    

### 27.4.2 Array 생성자 함수

- Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작
- new 연산자와 함께 호출하지 않아도 배열을 생성하는 생성자 함수로 동작함(Array 생서자 함수 내부에서 new.target을 확인하기 때문

### 27.4.3 Array.of(ES6)

- 전달된 인수를 요소로 갖는 열 생성
- Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열 생성
    
    ```jsx
    Array.of(1); // -> [1]
    // 생성자 함수는 length 프롶티 값이 인수인 배열을 생성함
    const arr = new Array(1) // -> [empty * 10] 
    ```
    

### 27.4.4 Array.from(ES6)

- 유사 배열 객체 or 이터러블 객체를 인수로 전달 받아 배열로 변환하여 반환
- 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소 채우기 가능
    
    ```jsx
    // Array.from은 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다
    Array.from({length:3}, (_, i) => i); // -> [0,1,2]
    ```
    

## 27.6 배열 요소의 추가와 갱신

- 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 됨
- 인덱스로 요소에 접근하여 명시적으로 값을 할당하지 않은 요소는 생성되지 않는다.
- 정수 이외의 값을 인덱스처럼 사용하면 요소 생성 ❌  대신 프로퍼티가 생성됨. 추가된 프로퍼티는 length 프로퍼티 값에 영향 ❌

## 27.7 배열 요소의 삭제

- delete 연산자는 개겣의 프로퍼티를 삭제하기 때문에 희소 배열을 만들 수 있음 → 사용하지 않는 것이 좋음
- 희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 `Array.prototype.splice` 메서드를 사용

## 27.8 배열 메서드

- **배열에는 원본 배열(배열 메서드를 호출한 배열. 배열 메서드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드 존재**
- ES5부터 도입된 배열 메서드는 대부분 원본 배열을 직접 변경하지 않음
- 초창기 배열 메서드는 원본 배열을 직접 변경하는 경우가 많음
    
    → 외부 상태를 직접 변경하는 사이드 이펙트가 있으니 주의
    
- 가급적이면 원본 배열을 변경하지 않는 메서드를 사용하는 것이 좋음

### 27.8.3 Array.prototype.indexOf

- 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환(없다면 -1을 반환)
- indexOf 메서드 대신 ES7에서 도입된 Array.prototype.includes 메서드를 사용하면 가독성이 더 좋음

### 27.8.4 Array.prototype.push

- 성능 면에서 안 좋음
- 마지막 요소로 추가할 요소가 하나뿐인 경우 push 메서드보다 length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가하는 것이 더 빠름
- **push 메서드는 원본 배열을 직접 변경함 → ES6의 스프레드 문법을 사용하는 것이 나음**

### 27.8.5 Array.prototype.unshift

- 인수로 전달 받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환
- **unshift 메서드는 원본 배열을 직접 변경함 → ES6의 스프레드 문법을 사용하는 것이 나음**

### 27.8.8 Array.prototype.splice

- 원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는 경우에 사용.
- splice 메서드는 원본 배열을 직접 변경함

### 27.8.9 Array.prototype.slice

- 인수로 전달된 범위의 요소들을 복사하여 배열로 반환
- 원본 배열은 변경되지 않음
- **`slice` 메서드는 1차원 배열에서는 깊은 복사를 수행하지만, 2차원 배열에서는 얕은 복사를 수행함**
    
    **→ `slice` 메서드는 항상 얕은 복사를 수행하지만, 1차원 배열의 경우에는 원소들이 원시 값이기 때문에 깊은 복사처럼 보임. 2차원 배열의 경우 배열 내의 배열들은 참조 값이기 때문에 얕은 복사로 동작**
    

### 27.8.12  Array.prototype.fill(ES6)

- 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채움
- 원본 배열을 변경함
- `fill` 메서드는 모든 요소를 하나의 값으로만 채움
- `Array.from` 메서드를 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 요소 값을 만들면서 배열을 채울 수 있음

### 27.8.14  Array.prototype.flat(ES10)

- 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화함

```jsx
[1, [2,3,4,5]].flat(); // -> [1,2,3,4,5]
```

## 27.9 배열 고차함수

- 고차 함수 : 함수를 인수로 전달받거나 함수를 반환하는 함수
- 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 둠
- 함수형 프로그래밍
    - 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 사태 변경을 피하려는 프로그래밍 패러다임
    - 순수 함수를 통해 사이드 이펙트를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려고 함

### 27.9.1 Array.prototype.sort

- 배열의 요소를 정렬
- 원본 배열을 직접 변경하여 정렬된 배열을 반환
    
    <aside>
    ❓ JS 배열 고차함수는 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 둔다는데 sort는 원본 배열을 변경하잖아 그럼 전제가 틀린거아닌가?
    
    </aside>
    
    <aside>
    📌 **JavaScript의 배열 고차 함수들은 일반적으로 함수형 프로그래밍의 원칙을 따르려고 하지만, 모든 메서드가 불변성을 유지하는 것은 아님. `sort`는 원본 배열을 변경하는 예외적인 메서드로, 함수형 프로그래밍의 원칙을 따르려면 배열을 복사한 후 사용하는 것이 좋다!**
    
    </aside>
    
- `sort` 메서드의 기본 정렬 순서는 유니코드 코드 포인트의 순서를 따름
    - **배열의 요소가 숫자 타입이어도 배열의 요소를 일시적으로 문자열로 변환한 후 유니코드 코드 포인트의 순서를 기준으로 정렬**
    - **따라서 숫자 요소를 정렬할 때는 `sort` 메서드에 정렬 순서를 정의하는 비교 함수를 인수로 전달해야함. 비교 함수는 양수나 음수 or 0을 반환해야한다**

### 27.9.2 Array.prototype.forEach

- for 문을 대체할 수 있는 고차함수
- `forEach` 메서드의 콜백함수는 `forEach` 메서드를 호출한 배열의 요소값과 인덱스, forEach 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받을 수 있음
    
    → `forEach` 메서드는 콜백함수 호출시 3개의 인수(`forEach` 메서드를 호출한 배열의 요소 값과 인덱스, `forEach` 메서드를 호출한 배열(this)을 순차적으로 전달
    
- `forEach` 메서드는 원본 배열을 변경하지 않으나 콜백 함수를 통해 원본 배열을 변경할 수 있음
- `forEach` 메서드의 반환 값은 언제나 undefined
- `forEach` 메서드의 콜백함수는 일반 함수로 호출되므로 콜백 함수 내부의 this는 undefined를 가리킴
    - this가 전역 객체가 아닌 undefined를 가리키는 이유 
    클래스 내부의 모든 코드에는 암묵적으로 strict mode가 적용되기 때문
- `forEach` 메서드의 polyfill
    
    ```jsx
    // 만약 Array.prototype에 forEacth 메서드가 존재하지 않으면 폴리필을 추가
    if (!Array.prototype.forEach) {
      Array.prototype.forEach = function (callback, thisArg) {
      // 첫번째 인수가 함수가 아니면 TypeError 발생
        if (typeof callback !== 'function') {
          throw new TypeError(callback + 'is not a function');
        }
    
        // this로 사용할 두 번재 인수를 전달받지 못하면 전역 객체를 this로 사용함
        thisArg = thisArg || window;
    		// for 문으로 배열을 순회하면서 콜백 함수를 호출 
    		// 이 때 콜백 함수의 인ㅈ수로 배열 요소, 인덱스, 배열 자신을 전달함
        for (let i = 0; i < this.length; i++) {
          callback.call(thisArg, this[i], i, this);
        }
      };
    }
    ```
    
- `f**orEach` 메서드는 for문과 달리 break, continue 문 사용 불가능 → 배열의 모든 요소를 모두 순회하며 중간에 순회를 중단할 수 없음**
- `forEach` 메서드는 for문에 비해 성능이 좋진 않지만 가독성이 좋음 
→ 요소가 많은 배열을 순회하거나 시간이 많이 걸리는 복잡한 코드 or 높은 성능이 필요한 게 아니라면 `forEach` 메서드를 사용하는 것이 나음

### 27.9.3 Array.prototype.map

- 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복호출
- **콜백 함수의 반환값들로 구성된 새로운 배열을 반환(원본 배열은 변경되지 않음)**
- **`map` 메서드가 생성하여 반환하는 새로운 배열의 length의 length 프로퍼티 값은 `map` 메서드를 호출한 배열의 length 프로퍼티 값과 반드시 일치**
    
    **→ `map` 메서드를 호출한 배열과 `map` 메서드가 생성하여 반환한 배열을 일대일로 매핑**
    
    ![image](https://github.com/deep-dive-to-javascript/deep-dive/assets/66353188/f8adf522-e337-4439-a329-a153bd505c38)

- `map` 메서드의 polyfill
    
    ```jsx
    if (!Array.prototype.map) {
      Array.prototype.map = function (callback, thisArg) {
        if (typeof callback !== 'function') {
          throw new TypeError(callback + 'is not a function');
        }
        // 원본 배열과 동일한 길이의 배열을 반환하므로 
        // arr을 동일한 길이의 배열로 만들고 
        // 콜백 함수가 반환하는 요소들을 순서대로 arr에 담아 리턴 
        var arr = new Array(this.length);
        thisArg = thisArg || window;
        for (let i = 0; i < this.length; i++) {
          arr[i] = callback.call(thisArg, this[i], i, this);
        }
        return arr;
      };
    }
    ```
    
- mdn에서 작성한 `map` 메서드의 polyfill
    
    [Array.prototype.map() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
    

### 27.9.4 Array.prototype.filter

- 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백함수를 반복 호출
- **콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환(원본 배열을 변경되지 않음)**
- 자신이 호출한 배열에서 필터링 조건을 만족하는 특정 요소로만 추출하여 새로운 배열을 만들고 싶을 때 사용
- **`filter` 메서드가 생성하여 반환한 새로운 배열의 length 프로퍼티 값은 `filter` 메서드를 호출한 배열의 length 프로퍼티 값과 같거나 작음**
    
    ![image](https://github.com/deep-dive-to-javascript/deep-dive/assets/66353188/9c361cc5-5ca1-42cb-b950-0ade58e53102)

- `filter` 메서드를 사용해 특정 요소 제거시 특정 요소가 중복되어 있으면 중복된 요소를 모두 제거됨
    
    → 특정 요소를 하나만 제거하려면 `indexOf` 메서드를 통해 특정 요소의 인덱스를 취득 후 `splice` 메서드를 사용
    
- `filter` 메서드의 polyfill
    
    ```jsx
    if (!Array.prototype.filter) {
      Array.prototype.filter = function (callback, thisArg) {
        if (typeof callback !== 'function') {
          throw new TypeError(callback + 'is not a function');
        }
        var arr = [];
        thisArg = thisArg || window;
        for (let i = 0; i < this.length; i++) {
          if (callback.call(thisArg, this[i], i, this)) {
            arr.push(this[i]);
          }
        }
        return arr;
      };
    }
    ```
    
- mdn에서 작성한 `filter` 메서드의 polyfill
    
    [Array.prototype.filter() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
    

### 27.9.5 Array.prototype.reduce

- 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출
- **콜백 함수의 반환값을 다음 순회 시 콜백함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 하나의 결과값을 만들어 반환(원본 배열은 변경되지 않음)**
- `reduce` 메서드는 첫 번째 인수로 콜백 함수, 두 번째 인수로 초기값을 전달 받음
- `reduce` 메서드의 콜백함수에는 4개의 인수, 초기값 or 콜백함수의 이전 반환값, `reduce` 메서드를 호출한 배열의 요소 값과 인덱스, `reduce` 메서드를 호출한 배열 자체. 즉, this가 전달됨
- **`reduce` 메서드를 호출할 때는 언제나 초기값을 전달하는 것이 안전**

### 27.9.6 Array.prototype.some

- 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 호출
- 콜백 함수의 반환값이 단 한번이라도 참이면 ture, 모두 거짓이면 false를 반환
배열의 요소 중 콜백 함수를 통해 정의한 조건을 만족하는 요소가 1개 이상 존재하는지 확인하여 그 결과를 불리언 타입으로 반환
- `soem` 메서드를 호출한 배열이 빈 배열인 경우 언제나 false를 반환

```jsx
// 배열의 요소 중 10보다 큰 요소가 1개 이상 존재하는지 확인
[5, 10, 15].some(item => item > 10); // -> true
```

### 27.9.7 Array.prototype.every

- 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 호출
- 콜백 함수의 반환값이 모두 참이면 true, 단 한번이라도 거짓이면 false를 반환
    
    배열의 모든 요소가 콜백함수를 통해 정의한 조건을 모두 만족하는지 확인하여 그 결과를 불리언 타입으로 반환
    
- `every` 메서드를 호출한 배열이 빈 배열인 경우 언제나 true를 반환

```jsx
// 배열의 모든요소가 3보다 큰지 확인
[5, 10, 15].every(item => item > 3); // -> true
```

# 28장 - Number

- 표준 빌트인 객체인 Number는 원시 타입인 숫자를 다룰 때 유용한 프로퍼티와 메서드를 제공함

### 28.3.2 Number.isInteger(ES6)

- 인수로 전달된 숫자 값이 정수인지 검사하여 그 결과를 불리언 값으로 반환
- 검사하기 전 인수를 숫자로 암묵적 타입 변환하지 않음

### 28.3.3 Number.isNaN(ES6)

- 인수로 전달된 숫자 값이 NaN인지 검사하여 그 결과를 불리언 값으로 반환
- 빌트인 전역 함수 isNaN과는 차이가 있음
    - 빌트인 전역 함수 isNaN은 전달받은 인수를 숫자로 암묵적 타입 변환하여 검사를 수행

### 28.3.6 Number.prototype.toFixed

- 숫자를 반올림하여 문자열로 반환
- 반올림하는 소수점 이하 자릿수를 나타내는 0~20 사이의 정수값을 진수로 전달 가능. 인수생략시 기본값 0

```jsx
// 소수점 이하 반올림. 인수생략시 기본값 0이 지점
(12345.6789).toFixed(); // -> "12346"
```

### 28.3.7 Number.prototype.toPrecision

- 인수로 전달받은 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환
    
    전체 자릿수로 표현할 수 없는 경우 지수 표기법으로 결과를 반환
    

```jsx
// 전체 자릿수 유효. 인수 생략시 기본값 0이 지점
(12345.6789).toPrecision(); // -> "12345.6789"
```

# 30장 - Date

- 표준 빌트인 객체인 Date는 날짜와 시간(연, 월, 일, 시, 분, 초, 밀리초)을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수
- UTC는 국제표준시로 GMT로 불리기도 함. 
UTC와 GMT는 초의 소수점 단위에서만 차이가 나서 혼용되어 사용되며 기술적인 표기에선 UTC가 사용됨
- KST(한국 표준시)는 UTC에 9시간을 더한 시간 → KST가 UTC보다 9시간이 빠름
- 현재 날짜와 시간은 자바스크립트 코드가 실행된 시스템의 시계에 의해 결정

됨

## 30.2 Date 메서드

### 30.2.25 date.prototype.toLocaleString

- 인수로 전달한 로캘을 기준으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환
- 인수 생략시 브라우저가 동작 중인 시스템의 로켈을 적용

```jsx
const today = new Date('2020/7/24/12:30');
today.toString(); // 'Fri Jul 24 2020 12:30:00 GMT+0900 (한국 표준시)'
today.toLocaleString('ko-KR'); // '2020. 7. 24. 오후 12:30:00'
```

### 30.2.26 date.prototype.toLocaleTimeString

- 인수로 전달한 로캘을 기준으로 Date 객체의 시간을 표현한 문자열을 반환

# 31장 - RegExp

## 31.1 정규 표현식이란?

- 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용되는 형식 언어
- 자바스크립트 고유 문법이 아니며 대부분의 프로그래밍 언어와 코드 에디터에 내장되어있음
- 자바스크립트는 펄의 정규 표현식 문법을 ES3부터 도입
- 정규 표현식은 문자열을 대상으로 패턴 매칭 기능을 제공함

## 31.2 정규표현식의 생성

![image](https://github.com/deep-dive-to-javascript/deep-dive/assets/66353188/fb27e393-9802-4e30-befc-5ccdbf326309)

- 정규표현식 객체를 생성하기 위해서는 정규 표현식 리터럴과 RegExp 생성자 함수를 사용할 수 있음
- 정규 표현식의 리터럴은 패턴과 플래그로 구성됨
    
    ```jsx
    const target = 'Is this all there is?';
    // 패턴: is
    // 플래그 : i => 대소문자를 구분하지 않고 검색 
    const regexp = /is/i;
    // test 메서드는 target 문자열에 대해 정규표현식regexp의 패턴을 검색하여 
    // 매칭 결과를 불리언 값으로 반환
    regexp.test(target); // -> true
    ```
    
- RegExp 생성자 함수 사용
    
    ```jsx
    /**
     * pattern : 정규 표현식의 패턴
     * flags : 정규 표현식의 플래그(g, i, m, u, y)
     */
     new RegExp(pattern[, flags])
    ```
    
    ```jsx
    const target = 'Is this all there is?';
    const regexp = new RegExp(/is/i); // ES6
    regexp.test(target); // -> true
    ```
    

## 31.3 RegExp 메서드

### 31.3.1 RegExp.prototype.exec

- 인수로 전달받은 문자열에 대해 정규표현식의 패턴을 검색하여 매칭 결과를 배열로 반환
- 매칭 결과가 없는 경우 null 반환
- 문자열 내의 모든 패턴을 검색하는 `g 플래그` 를 지정해도 첫 번째 매칭 결과만 반환하므로 주의

### 31.3.2 RegExp.prototype.test

- 인수로 전달받은 문자열에 대해 정규표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환

### 31.3.3 String.prototype.match

- String 표준 빌트인 객체가 제공
- 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환
- `g 플래그`가 지정되면 모든 매칭 결과를 배열로 반환

## 31.4 플래그

- 중요한 3개의 플래그
    
    
    | 플래그 | 의미 | 설명 |
    | --- | --- | --- |
    | i | ignore case | 대소문자 구별하지 않고 패턴 검색 |
    | g | Global | 대상 문자열 내에서 패턴과 일치하는 모든 문자열 전역 검색 |
    | m | Multi line | 문자열 행이 바뀌더라도 패턴 검색 계속함 |
- 정규 표현식 관련 참고 사이트
    
    [📚 JavaScript 정규 표현식 문법 총정리 + 응용 예제](https://inpa.tistory.com/entry/JS-📚-정규식-RegExp-누구나-이해하기-쉽게-정리#정규식_기호_모음)
    

# 32장 - String

## 32.1 String 생성자 함수

- 표준 빌트인 객체인 String 객체는 생서자 함수 객체
    
    → new 연산자와 함게 호출하여 String 인스턴스 생성가능
    
- String 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성함
- String 래퍼 객체는 유사 배열 객체이며 이터러블 → 배열과 유사하게 인덱스를 사용하여 각 문자에 접근 가능
- 단, 문자열을 원시 값이므로 변경 불가능하지만 시도를 해도 에러는 발생하지 않음

## 32.3 String 메서드

- String 객체에는 원본 String 래퍼 객체를 직접 변경하는 메서드가 존재하지 않음 
→ String 객체의 메서드는 언제나 새로운 문자열을 반환. **문자열은 변경 불가능한 원시값이므로 String 래퍼 객체도 읽기 전용 객체로 제공됨**

### 32.3.3. String.ptorotype.includes(ES6)

- 대상 문자열에 인수로 전달 받은 문자열이 포함되어있는지 확인하여 그 결과를 true or false 로 반환

### 32.3.4. String.ptorotype.startWith(ES6)

- 대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 true or false 로 반환

### 32.3.5. String.ptorotype.endWith(ES6)

- 대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 true or false 로 반환

### 32.3.7. String.ptorotype.substring

- 대상 문자열에서 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열을 반환
- 두번째 인수 생략 가능(이 경우 첫 번째 인수로 전달한 인덱스에 위치하는 문자부터 마지막 문자까지 부분 문자열 반환)
- 인덱스는 문자열의 범위(0부터 문자열 길이 -1)사이의 정수여야함

### 32.3.8. String.ptorotype.slice

- `substring` 메서드와 동일하게 동작
- `substring` 메서드와 달리 음수인 인수 전달 가능(이 경우 대상 문자열의 가장 뒤에서부터 시작하여 문자열을 잘라내어 반환)

### 32.3.14. String.ptorotype.split

- 대상 문자열에서 첫 번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환
- 인수로 빈 문자열을 전달하면 각 문자를 모두 분리하고 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환함

# 💭 느낀점
