### 27장. 배열

- 배열

  - 여러 개의 값을 순차적으로 나열한 자료 구조

  - 객체 타입

  - vs 일반 객체

    | 구분                | 객체                      | 배열          |
    | ------------------- | ------------------------- | ------------- |
    | 구조                | 프로퍼티 키 / 프로퍼티 값 | 인데스 / 요소 |
    | 값 참조             | 프로퍼티 키               | 인덱스        |
    | **값 순서**         | 없음                      | 있음          |
    | **length 프로퍼티** | 있음                      | 없음          |

  - vs 일반 배열

    - 일반 배열 (자료구조에서 말하는 일반적인 배열)
      - 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조
      - 인덱스 요소에 빠르게 접근 가능
      - 삽입/삭제에 비효율적
    - 자바스크립트 배열
      - 일반적인 배열의 동작을 흉내 낸 특수한 객체 (해시 테이블로 구현된 객체)
        - 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 괜찮음.
        - 연속적으로 이어져 있지 않을 수 있음. &rarr; 희소 배열 (생성하지 않도록 주의 &larr; 배열에는 같은 타입 요소를 연속적으로 위치시키는 것이 최선)
      - 일반 배열에 비해 느린 성능
      - 삽입/삭제 시, 일반 배열보다 빠른 성능

  - length 프로퍼티 

    - 요소의 개수 &rarr; 배열의 길이를 나타내는 0 이상의 정수
    - 임의의 숫자 명시적으로 할당 가능
      - 현재 값보다 큰 숫자 할당하는 경우 프로퍼티 값은 변경되지만 실제 배열 길이는 변동 없음.

  - 배열 메서드

    - 다양하고 유용한 빌트인 메서드 제공

    - > [!IMPORTANT]
      > 결과물 반환 패턴 2가지
      >
      > - 원본 배열 직접 변경 O
      > - 원본 배열 직접 변경 X &rarr; 새로운 배열 생성 후 반환

    - > [!TIP]
      >
      > 원본 배열을 수정하지 않아야 하는 이유
      >
      > 	1. 불변성 유지 (Immutability): 데이터의 상태를 예측 가능하게 유지 가능하게 하여 디버깅을 편리하게 하고 버그를 줄이는데 도움을 준다.
      > 	
      > 	2. 사이드 이펙트 방지 (Avoid Side Effects): 원본 배열을 수정하는 메소드는 사이드 이펙트를 일으킬 수 있습니다. 이는 함수 외부의 상태를 변경하여 예기치 않은 결과를 초래할 수 있습니다. 반면, 원본 배열을 수정하지 않는 메소드는 사이드 이펙트를 방지하여 코드의 안정성을 높입니다.
      > 	
      > 	3. 가독성 향상 (Improved Readability): 코드의 가독성이 향상됩니다. 원본 배열을 수정하지 않는 메소드를 사용하면, 원본 배열이 유지된다는 것을 명확히 알 수 있어 코드의 의도를 쉽게 파악할 수 있습니다.
      > 	
      > 	4. 성능 고려 (Performance Considerations): 경우에 따라 원본 배열을 수정하는 것이 성능상 이점을 가질 수 있습니다. 예를 들어, 대규모 배열을 처리할 때 새로운 배열을 생성하지 않으면 메모리 사용량을 줄일 수 있습니다.
      > 	
      > 	5. 협업과 유지보수 (Collaboration and Maintenance): 팀원들과 협업할 때, 원본 배열을 수정하는 메소드와 수정하지 않는 메소드를 명확히 구분하면 코드 유지보수가 쉬워집니다. 다른 개발자들이 코드의 동작 방식을 쉽게 이해하고 예측할 수 있습니다.

    - Array.prototype.push
      - 원본 배열 직접 변경 &rarr; 스프레드 문법 사용하는 편이 더 좋다.
      - 인자값들을 원본 배열 마지막 요소로 추가, 변경된 length 프로퍼티 값 반환
      - 성능이 좋지 않으므로 length 요소를 활용하여 직접 추가하는 것이 더 빠름.
    - Array.prototype.pop
      - 원본 배열 직접 변경
      - 마지막 요소 제거 후, 제거한 요소 반환
      - 빈 배열 시, undefined 반환
    - Array.prototype.splice
      - 원본 배열 직접 변경
      - 배열 중간에 요소를 추가하거나 중간에 있는 요소 제거하는 경우
    - Array.prototype.slice
      - **원본 배열 그대로 유지**
      - 인수로 전달된 범위 요소들을 복사하여 배열로 반환
    - Array.prototype.includes
      - 배열 내 특정 요소 표함되어 있는지 확인
    - Array.prototype.flat
      - **원본 배열 그대로 유지**
      - 인수로 전달한 깊이만큼 재귀적으로 배열 평탄 (다차원 배열을 1차원 배열로 변환)

  - 배열 고차 함수

    - 함수를 인수로 전달받거나 함수를 반환하는 함수
    - 불변성 지향
      - Array.prototype.sort
        - 원본 배열 직접 변경
        - 정렬된 배열 반환
        - 정렬 순서 유니코드 포인트 순서를 따르기 때문에 숫자 요소로 이루어진 배열의 경우 주의할 것 (배열의 요소를 일시적으로 문자열로 변환 후 기준 적용) &rarr; 정렬 순서를 정의하는 비교 함수를 인수로 전달
          - ECMAScript 부터 timsort 알고리즘 (이전에는 quick sort 알고리즘)
      - Array.prototype.forEach
        - 콜백 함수 내부에서는 원본 배열 직접 변경 가능
        - 배열 순회하며 수행해야할 처리를 콜백 함수로 전달받아 반복 호출
        - break, continue 문 사용 불가
        - undefined 반환
        - 반복문 대체하는 고차 함수
      - Array.prototype.map
        - **원본 배열 그대로 유지**
        - 배열 순회하며 인수로 전달 받은 콜백함수 반복 호출 &rarr; 콜백 함수의 반환값들로 구성된 새로운 배열 반환
        - 요소값을 다른 값으로 매핑한 새로운 배열을 생성하기 위한 고차 함수
        - map 메서드 호출 배열과 map 메서드 생성하여 반환한 배열 1:1 매핑
      - Array.prototype.filter
        - **원본 배열 그대로 유지**
        - 배열 순회하며 인수로 전달 받은 콜백함수 반복 호출 &rarr; 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열 반환
        - 새로운 배열 length >= 메서드 호출 배열 length
        - vs find
          - find 메서드 : 반환값이 true인 첫번째 요소만 반환
      - Array.prototype.reduce
        - **원본 배열 그대로 유지**
        - 배열 순회하며 인수로 전달 받은 콜백함수 반복 호출 &rarr; 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 하나의 결과값을 만들어 반환
        - 배열의 length 만큼 호출
      - Array.prototype.some
        - 배열 순회하며 인수로 전달 받은 콜백함수 반복 호출 &rarr; 콜백 함수의 반환값이 단 한번이라도 참이면 true, 모두 거짓인 경우에 false 반환
      - Array.prototype.every
        - 배열 순회하며 인수로 전달 받은 콜백함수 반복 호출 &rarr; 콜백 함수의 반환값이 모두 참이면 true, 단 한번이라도 거짓이면 false 반환

### 28장. Number

- Number 객체는 생성자 함수 객체 &rarr; Number 인스턴스 생성 가능
- 숫자가 아닌 값 전달 시, 숫자로 강제 변환 후 할당 ( 변환 불가능하다면 NaN 할당)
- new 연산자 미 사용시, 인스턴스가 아닌 숫자 반환 (타입 변환 가능)
- 메서드
  - Number.prototype.isInteger 
    - 인수 암묵적 타입 변환 X
    - 인수로 전달된 숫자값이 정수인지 검사
  - Number.prototype.isNaN
    - 인수 암묵적 타입 변환 X ( vs 전역 함수 isNaN(암묵적 변환 O))
    - 인수로 전달된 숫자값이 NaN인지 검사
  - Number.prototype.toFixed
    - 인수 암묵적 타입 변환 O
    - 숫자 반올림하며 문자열로 반환
  - Number.prototype.toString
    - 인수 암묵적 타임 변환 O
    - 숫자를 문자열로 변환하여 반환

### 29장. Math

- 생성자 함수 X &rarr; 정적 프로퍼티와 정적 메서드만을 제공
- 메서드 : abs, round, ceil, floor, sqrt, random, pow, max

### 30장. Date

- 생성자 함수
  - 객체 생성 방법
    - new 연산자 사용
    - Date 생성자 함수에 숫자 타입의 밀리초/날짜와 시간을 나타내는 문자열/연,월,시,분,초,밀리초를 의미하는 숫자를 인수로 전달
- 메서드
  - get/set 연도, 월, 일 요일, 시간
  - getTimezondeOffset : UTC(세계 표준 시간)와 locale 시간과의 차이를 분 단위로 반환
  - toISOString : ISO 8601 형식으로 객체의 날짜와 시간 표현한 문자열 반환
  - toLocalString : 인수로 전달한 로컬을 기준으로 Date 객체 날짜 시간 문자열 반환
  - toLocalTimeString : 인수로 전달한 로컬을 기준으로 Date 객체 시간 문자열 반환

### 31장. RegExp

- 정규 표현식

  - 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어

  - 문자열을 대상으로 패턴 매칭 기능(특정 패턴과 일치하는 문자열을 검색하거나 추출/치환) 제공

  - 장점 : 반복문/조건문 없이 패턴 정의 및 체크 가능

  - 단점 : 가독성이 좋지 않음

  - 생성

    - 정규 표현식 리터럴
    - new 연산자 사용하여 RegExp 생성자 함수 사용

  - 메서드

    - RegExp.prototype.exec

      - 인수로 전달받은 문자열에 대해 패턴을 검색하여 첫번째 매칭 결과를 배열로 변환
      - 매칭 결과가 없는 경우 null 반환

    - RegExp.prototype.test

      - 매칭 결과 불리언 값으로 반환

    - RegExp.prototype.match

      - 매칭 결과 배열로 반환

      - 패턴을 찾을 때 유용

        ```js
        const target = 'The quick brown fox jumps over the lazy dog.';
        const regExp = /\b\w{4}\b/g; // 4글자 단어 찾기
        const result = target.match(regExp);
        console.log(result); // -> ["quick", "over", "lazy"]
        ```

  - **플래그**

    | 플래그 | 의미        | 설명                                    |
    | ------ | ----------- | --------------------------------------- |
    | i      | Ignore case | 대소문자 구별 X                         |
    | g      | Global      | 패턴과 일치하는 모든 문자열 전역 검색   |
    | m      | Multi line  | 문자열의 행이 바뀌더라도 패턴 검색 계속 |

    - 기본적으로는 정규표현식 단일 행에서 작동

    ```js
    const regexSingleLine = /^hello/;
    const regexMultiLine = /^hello/m;
    const text = `hello world
    hello universe`;
    
    // 단일 행 모드에서는 첫 번째 줄만 매칭합니다.
    console.log(text.match(regexSingleLine)); // ["hello"]
    
    // 다중 행 모드에서는 모든 줄의 시작 부분을 매칭합니다.
    console.log(text.match(regexMultiLine)); // ["hello", "hello"]
    ```

  - 자주 사용하는 정규 표현식

    - 특정 단어로 시작

    ```js
    const target = 'https://poiemaweb.com';
    
    // 'https'로 시작하는지 검사한다.
    const regExp = /^https/;
    
    regExp.test(target); // -> true
    
    const url = 'https://example.com';
    
    // 'http://' 또는 'https://'로 시작하는지 검사한다.
    /^https?:\/\//.test(url); // -> true
    ```

    - 특정 단어로 끝나는지 

    ```js
    const target = 'https://poiemaweb.com';
    
    // 'com'으로 끝나는지 검사한다.
    const regExp = /com$/;
    
    regExp.test(target); // -> true
    ```

    - 사용 가능한 아이디인지

    ```js
    const id = 'abc123';
    
    // 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~ 10자리인지 검사한다.
    /^[A-Za-z0-9]{4,10}$/.test(id); // -> true
    ```

    - 형식에 맞는지

    ```js
    const email = 'ungmo2@gmail.com';
    
    /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/.test(email); // -> true
    
    const cellphone = '010-1234-5678';
    
    /^\d{3}-\d{3,4}-\d{4}$/.test(cellphone); // -> true
    
    
    ```

    - 특수 문자 포함 여부 검사 / 제거

    ```js
    (/[\{\}\[\]\/?.,;:|\)*~`!^\-_+<>@\#$%&\\\=\(\'\"]/gi).test(target); // -> true
    
    target.replace(/[^A-Za-z0-9]/gi, ''); // -> abc123
    ```

> [!TIP]
> 정규표현식 생성 사이트
>
> 1. **Regex101** (https://regex101.com/)
>    - 다양한 프로그래밍 언어(자바스크립트 포함)를 지원하며, 정규표현식의 작동 방식을 상세히 설명해줍니다.
>    - 실시간으로 정규표현식을 테스트하고 결과를 확인할 수 있습니다.
> 2. **RegExr** (https://regexr.com/)
>    - 사용자 친화적인 인터페이스와 함께 정규표현식을 작성하고 테스트할 수 있습니다.
>    - 각 부분의 의미를 설명해주는 기능과 함께 커뮤니티에서 공유된 예제도 볼 수 있습니다.
> 3. **RegexPal** (http://www.regexpal.com/)
>    - 간단하고 직관적인 인터페이스를 제공하여 다양한 정규표현식을 빠르게 테스트할 수 있습니다.
>    - 실시간으로 매칭 결과를 확인할 수 있습니다.
>    - 이메일, 전화번호, 날짜 등 일반적인 패턴에 대한 정규표현식을 생성할 수 있습니다.
> 4. **RegexPlanet** (https://www.regexplanet.com/advanced/javascript/index.html)
>    - 다양한 프로그래밍 언어에 맞춘 정규표현식을 테스트할 수 있으며, 자바스크립트도 지원합니다.
>    - 매칭 결과와 함께 정규표현식의 성능도 확인할 수 있습니다.
> 5. **Regex Generator** (https://regex-generator.olafneumann.org/)
>    - 원하는 문자열 패턴을 입력하면 해당 패턴을 만족하는 정규표현식을 생성해줍니다.
>    - 생성된 정규표현식을 테스트할 수 있는 기능도 제공합니다.
> 6. **Regex Buddy** (https://www.regexbuddy.com/)
>    - 정규표현식 생성, 테스트, 디버깅 등 다양한 기능을 제공합니다.
>    - 사용자 정의 패턴을 입력하여 정규표현식을 생성할 수 있습니다.
> 7. **Regex 101** (https://regex101.com/)
>    - 정규표현식 생성기 외에도 다양한 정규표현식 관련 기능을 제공합니다.
>    - 생성된 정규표현식을 실시간으로 테스트할 수 있습니다.

### 32장. String

- 생성자 함수 객체 &rarr; new 연산자와 함께 호출
  - 인수 전달하지 않고 호출 시, 빈 문자열을 할당한 String 래퍼 객체 생성
  - length 프로퍼티와 인덱스를 가지는 유사 배열 객체 / 이터러블
    - 인덱스로 접근 가능 &rarr; 원시값인 경우 변경 불가능인데, 에러 발생하지 않음.
  - 숫자가 아닌 값 인수로 전달 시, 강제 변환 후. ㅏㄹ당
  - 연산자 사용하지 않으며 생성자 함수 호출 시, 문자열 반환 &rarr; 명시적 타입 변환 가능
- 메서드
  - String.prototype.search : 인수(정규표현식)과 매치하는 문자열 검색하여 일치하는 문자열 인덱스 반환
  - String.prototype.startsWith/endsWith : 인수로 받은 문자열로 시작하는/끝나는 지 확인
  - String.prototype.subString : 첫번째 인수 인덱스에 위치하는 문자부터 두번째 인수 인덱스 위치하는 문자 바로 이전까지의 부분 문자열 반환



### 느낀 점

다양한 메서드들을 공부해볼 수 있었습니다. 특히 정규표현식 부분을 학습하면서 평소에 궁금했던 회원가입 때마다  사이트마다 허용되는 특수문자가 다른 이유가 무엇일까? 질문에 대한 답을 찾아봤습니다. 보안/데이터무결성/사용자경험/표준 준수/기술적 제한(시스템 호환) 등의 문제로 인해서 달라진다고 합니다!



