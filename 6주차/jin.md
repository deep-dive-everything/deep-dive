### 21장. 빌트인 객체

- 표준 빌트인 객체

  - ECMA 사양에 정의된 객체로 자바스크립트 실행 환경에 관계없이 언제나 사용 가능
  - Object, String, Number, Boolean, Symbol, Date 등
  - Math, Reflect, JSON ( 정적 메서드만 제공) 을 제외한 표준 빌트인 객체는 생성자 함수 객체 &rarr; 인스턴스 생성 가능, 프로토타입 메서드와 정적 메서드 제공
  - 원시값에 대해 객체처럼 접근하면 자바스크립트 엔진이 암묵적으로 연관된 임시 객체(래퍼 객체)를 생성하여 생성된 객체로 프로퍼티에 접근, 메서드를 호출할 수 있도록 하고 다시 원시값으로 원복

- 호스트 객체

  - ECMA 사양에 정의되어있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체
  - 브라우저 : DOM, BOM 등과 같은 클라이언트 사이드 Wep API
  - Node.js : 호스트 API

- 사용자 정의 객체

  - 사용자가 직접 정의한 객체

- 전역 객체

  - 코드 실행 이전 단계에서 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체

  - 어떤 객체에도 속하지 않은 최상위 객체

  - 브라우저 : window

  - Node.js : global

  - 프로퍼티 : 표준 빌트인 객체 + 호스트 객체 + var로 선언한 전역 변수, 전역 함수 &rarr; 참조 시, window(global) 생략 가능

  - 개발자가 의도적으로 생성 불가능

  - 빌트인 전역 프로퍼티 : Infinity, NaN, undefined

  - 빌트인 전역 함수 : eval(런타임에 동적으로 수정되어 처리속도가 느리므로 사용 금지), isFinite, isNaN, parseFloat, encodeURI, decodeURI, encodeURIComponent, decodeURIComponent

  - 암묵적 전역 : 선언하지 않은 식별자에 값을 할당 시, 전역 객체의 프로퍼티로 등록 &rarr; 변수가 아님 &rarr; 변수 호이스팅 미발생, delte 연산자로 삭제 가능 (전역 변수는 delete 연산자로 삭제 불가능)

    ```js
    var x = 10; // 전역 변수
    
    function foo () {
      // 선언하지 않은 식별자에 값을 할당
      y = 20; // window.y = 20;
      
      // 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
      console.log(x + y); // 30
    }
    foo();//30
    
    // 전역 변수 x는 호이스팅이 발생한다.
    console.log(x); // undefined
    // 전역 변수가 아니라 단지 전역 객체의 프로퍼티인 y는 호이스팅이 발생하지 않는다.
    console.log(y); // ReferenceError: y is not defined
    
    console.log(window.x); // 10
    console.log(window.y); // 20
    
    delete x; // 전역 변수는 삭제되지 않는다.
    delete y; // 프로퍼티는 삭제된다.
    
    console.log(window.x); // 10
    console.log(window.y); // undefined
    
    ```

    

### 22장. this

> 동작을 나타나는 메서드는 자신이 속한 객체의 상태(프로퍼티)를 참조하고 변경할 수 있어야하는데, 자신이 속한 객체를 가리키는 식별자(this)를 참조할 수 있어야 한다.

- 생성자 함수를 정의하는 시점에는 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없으므로 자신이 속한 객체, 자신이 생성할 인스턴스를 가르키는 특수한 식별자 필요 &rarr; this
- 자바스크립트 엔진에 의해 암묵적으로 생성되어 함수 호출 시, arguments 객체와 함께 this도 암묵적으로 함수 내부에 전달
- 어디서나 참조 가능 (전역 + 함수 내부)
- this 바인딩 : this가 가르키는 값은 함수 호출 방식에 의해 동적으로 결정 (strict mode 영향도 받음)
  - 메서드(객체 리터럴 메서드, 일반 함수 메서드) 내부 : 메서드를 호출한 객체
  - 생성자 함수 내부 : 생성자 함수가 생성할 인스턴스
  - 전역 : window
  - strict mode 적용된 일반 함수 내부 this : undefined (객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서는 this를 사용할 필요가 없다.)
  - 일반 함수 (일반 함수로 호출된 모든 함수 (중첩 함수, 콜백 함수) : 전역 객체 (window)
  - this를 명시적으로 바인딩 하고 싶을 때는 that 사용 또는 Function.prototype.apply/call/bind 사용(첫번째 인수로 전달한 값으로 this 바인딩) 또는 화살표 함수 사용 (화살표 함수 내부의 this는 상위 스코프 this를 가르킴)



### 23장. 실행 컨텍스트

> 실행 컨텍스트는 소스 코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역.
>
> 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리

- 소스코드 타입 (구분 이유 : 소스 코드 타입에 따라 달라지는 실행 컨텍스트 실행, 관리)

  |      소스코드의 타입       | 설명                                                         |
  | :------------------------: | :----------------------------------------------------------- |
  |  전역 코드(`global code`)  | 전역에 존재하는 소스코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  | 함수 코드(`function code`) | 함수 내부에 존재하는 소스코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  |   eval 코드(`eval code`)   | 빌트인 전역함수인 eval함수에 인수로 전달되어 실행되는 소스코드를 말한다. |
  |  모듈 코드(`module code`)  | 모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

- 모든 소스코드

  1. 소스 코드 평가 (코드 실행 준비) 
     - 실행 컨텍스트 생성
     - 변수, 함수 등의 선언문만 먼저 실행 &rarr; 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드) 등록
  2. 소스 코드 실행
     - 선언문 제외한 소스 코드 순차적 실행 (= 런타임 시작)
       - 소스 코드 실행에 필요한 정보, 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에 검색해서 취득
       - 변수 값의 변경 등 소스코드 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록

- 실행 컨텍스트 스택 : 코드의 실행 순서 관리
  - 소스 코드가 평가되면 실행 컨텍스트가 생성 &rarr; 실행 컨텍스트 스택에 push
  - 함수가 호출되면 제어권리 호출된 함수로 넘어가며 해당 함수의 실행 컨텍스트가 생성되어 실행 컨텍스트 스택에 push
  - 함수가 종료되면 자바스크립트 엔진은 해당 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 pop
- 렉서컬 환경 : 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조 &rarr; 스코프와 식별자를 관리
  - 환경 레코드 : 스코프에 포함된 식별자를 등록, 등록된 식별자에 바인딩된 값을 관리
  - 외부 렉시컬 환경에 대한 참조 : 상위 스코프
