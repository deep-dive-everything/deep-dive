## 21장 빌트인 객체

### 21.1 자바스크립트 객체의 분류

- 표준 빌트인 객체
  - ECMAScript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능을 제공한다.
  - 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)과 관계없이 언제나 사용할 수 있다.
  - 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 따라서 별도 선언 없이 전역 변수처럼 언제나 참조할 수 있다.
- 호스트 객체
  - ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체를 말한다.
  - 브라우저: DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공
  - Node.js 환경: Node.js 고유의 API를 호스트 객체로 제공
- 사용자 정의 객체
  - 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.

### 21.2 표준 빌트인 객체

- 자바스크립트는 40여 개의 표준 빌트인 객체를 제공한다.
  - Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등
- Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.
  - 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고,
  - 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.
-

### 21.3 원시값과 래퍼 객체

{% note %}

**문자열이나 숫자, 불리언 등의 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는 무엇일까?**

{% endnote%}

- 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 원시값인 문자열이 마치 객체처럼 동작한다.

```js
const str = 'hello'

console.log(str.length) // 5
console.log(str.toUpperCase()) // HELLO
```

- 이는 원시값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법(또는 대괄호 표기법)으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다.
- 즉, 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.
- 이처럼 **문자열, 숫자, 불리언 값**에 대해 **객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체**라 한다.
- 문자열, 숫자, 불리언
  - 예를 들어 문자열에 대해 객체에 접근하는 것처럼 마침표 표기법으로 접근하면 그 순간 래퍼 객체인 String 생성자 함수의 인스턴스가 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
  - 이때 문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용할 수 있다.
  - 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.
  - 숫자 값은 문자열과 마찬가지다.
  - 불리언 값도 문자열이나 숫자와 마찬가지이지만 불리언 값으로 메서드를 호출하는 경우는 없으므로 그다지 유용하지는 않는다.
- 심벌도 래퍼 객체를 생성하지만 일반적인 원시값과는 달리 리터럴 표기법으로 생성할 수 없고 Symbol 함수를 통해 생성해야 하므로 다른 원시값과는 차이가 있다.
- 문자열, 숫자, 불리언, 심벌 이외의 원시값, 즉 null과 undefined는 래퍼 객체를 생성하지 않는다. 따라서 객체처럼 사용하면 에러가 발생한다.

### 21.4 전역 객체

- 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않는 최상위 객체다.
- 자바스크립트 환경에 따라 지칭하는 이름이 제각각이다.
  - 브라우저: window, self, this, frames
  - Node.js: global

> [!TIP]
>
> **globalThis**
>
> - ECMAScript2020(ES11)에서 도입된 `globalThis`는 브라우저 환경과 Node.js 환경에서 전역 객체를 가리키던 다양한 식별자를 통일한 식별자다.
> - 표준 사양이므로 ECMAScript 표준 사양을 준수하는 모든 환경에서 사용할 수 있다.

- 전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
- 즉, 전역 객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체다.
- 전역 객체가 최상위 객체라는 것은 프로토타입 상속 관계상에서 최상위 객체라는 의미가 아니다.
- **전역 객체 자신은 어떤 객체의 프로퍼티도 아니며 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 소유한다는 것을 말한다.**
- 전역 객체의 특징
  - 전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.
  - 전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.
  - 전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.
  - 자바스크립트는 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.
    - 브라우저: 클라이언트 사이드 Web API
    - Node.js: Node.js 고유의 API
  - var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.
  - let, const 키워드로 선언한 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 되므로 전역 객체의 프로퍼티가 아니다.
  - 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 이는 분리되어 있는 자바스크립트 코드가 하나의 전역을 공유한다는 의미다.
- 전역 객체의 프로퍼티와 메서드는 전역 객체를 가리키는 식별자, 즉 window나 global을 생략하여 참조/호출할 수 있으므로 전역 변수와 전역 함수처럼 사용할 수 있다.

#### 21.4.1 빌트인 전역 프로퍼티

- 빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 말한다. 주로 애플리케이션 전역에서 사용하는 값을 제공한다.

##### Infinity

- Infinity 프로퍼티는 무한대를 나타내는 숫자값 Infinity를 갖는다.

```js
console.log(window.Infinity === Infinity) // true
console.log(3 / 0) // Infinity
console.log(-3 / 0) // -Infinity
console.log(typeof Infinity) // number
```

##### NaN

- NaN 프로퍼티는 숫자가 아님(Not-a-Number)를 나타내는 숫자값 NaN을 갖는다.

```js
console.log(window.NaN) // NaN
console.log(Number('xyz')) // NaN
console.log(1 * 'string') // NaN
console.log(typeof NaN) // number
```

##### undefined

- undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.

```js
console.log(window.undefined) // undefined

var foo
console.log(foo) // undefined
console.log(typeof undefined) // undefined
```

#### 21.4.2 빌트인 전역 함수

- 빌트인 전역 함수는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드다.

##### eval

- eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 전달받는다.
- 전달받은 문자열 코드가 표현식이라면 런타임에 평가하여 값을 생성하고, 표현식이 아니라면 런타임에 실행한다.

```js
/**
 * 주어진 문자열 코드를 런타임에 평가 또는 실행한다.
 * @param {string} code - 코드를 나타내는 문자열
 * @return {*} 문자열 코드를 평가/실행한 결과값
 */
eval(code)
```

```js
// 표현식인 문
eval('1 + 2;') // 3

// 표현식이 아닌 문
eval('var x = 5;') // undefined
```

- eval 함수를 사용하면 안 되는 이유
  - eval 함수를 통해 사용자로부터 입력받은 콘텐츠를 실행하는 것은 보안에 매우 취약하다.
  - eval 함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드 실행에 비해 처리 속도가 느리다.

##### isFinite

- 전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환하고, 무한수이면 false를 반환한다.
- 전달받은 인수의 타입이 숫자가 아닌 경우 숫자로 타입을 변환한 후 검사를 수행한다.
- 인수가 무한수 또는 NaN으로 평가되는 값이라면 false를 반환한다.

```js
/**
 * 전달받은 인수가 정상적인 유한수인지 확인하고 그 결과를 반환한다.
 * @param {number} testValue - 검사 대상 값
 * @return {boolean} 유한수 여부 확인 결과
 */
isFinite(testValue)
```

##### isNaN

- 전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.
- 전달받은 인수의 타입이 숫자가 아닌 경우 숫자로 타입을 변환한 후 검사를 수행한다.

```js
/**
 * 전달받은 인수가 NaN인지 확인하고 그 결과를 반환한다.
 * @param {number} testValue - 검사 대상 값
 * @return {boolean} NaN 여부 확인 결과
 */
isNaN(testValue)
```

##### parseFloat

- 전달받은 문자열 인수를 부동 소수점 숫자, 즉 실수로 해석하여 반환한다.

```js
/**
 * 전달받은 문자열 인수를 실수로 해석하여 반환한다.
 * @param {string} string - 변환 대상 값
 * @return {number} 변환 결과
 */
parseFloat(string)
```

##### parseInt

- 전달받은 문자열 인수를 정수로 해석하여 반환한다. 전달받은 인수가 문자열이 아니면 문자열로 변환한 다음, 정수로 해석하여 반환한다.
- 두 번째 인수로 진법을 나타내는 기수(2~36)를 전달할 수 있다. 기수를 지정하면 첫 번째 인수로 전달된 문자열을 해당 기수의 숫자로 해석하여 반환한다. 이때 반환값은 언제나 10진수다.
- 기수를 생략하면 첫 번째 인수로 전달된 문자열을 10진수로 해석하여 반환한다.
- 참고로 기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 `Number.prototype.toString` 메서드를 사용한다.

```js
/**
 * 전달받은 문자열 인수를 정수로 해석하여 반환한다.
 * @param {string} string - 변환 대상 값
 * @param {number} [radix] - 진법을 나타내는 기수(2 - 36, 기본값 10)
 * @return {number} 변환 결과
 */
parseInt(string, radix)
```

##### encodeURI/decodeURI

- 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다.
- 이스케이프 처리는 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것이다.
- URI 문법 형식 표준 RFC3986에 따르면 URL은 아스키 문자 셋으로만 구성되어야 한다.
- 따라서 URL 내에서 의미를 갖고 있는 문자(%, ? , #)나 URL에 올 수 없는 문자(한글, 공백 등) 또는 시스템에 의해 해석될 수 있는 문자(<, >)를 이스케이프 처리하여 야기될 수 있는 문제를 예방해야 한다.
- 단, 알파벳, 0~9의 숫자, `- _ . ! ~ * ' ( )` 문자는 이스케이프 처리에서 제외된다.

```js
/**
 * 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.
 * @param {string} uri - 완전한 URI
 * @return {string} 인코딩된 URI
 */
encodeURI(uri)

/**
 * 인코딩된 URI를 전달받아 이스케이프 처리 이전으로 디코딩한다.
 * @param {string} encodeURI - 인코딩된 URI
 * @return {string} 디코딩된 URI
 */
decodeURI(encodeURI)
```

##### encodeURIComponent/decodeURIComponent

- `encodeURIComponent` 함수는 인수로 전달된 문자열을 URI의 구성요소인 쿼리 스트링 일부로 간주한다. 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &까지 인코딩한다.
- `encodeURI` 함수는 매개변수로 전달된 문자열을 완전한 URI 전체라고 간주하고 쿼리 스트링 구분자로 사용되는 =, ?, &은 인코딩하지 않는다.

```js
/**
 * URI의 구성요소를 전달받아 이스케이프 처리를 위해 인코딩한다.
 * @param {string} uriComponent - URI의 구성요소
 * @return {string} 인코딩된 URI의 구성요소
 */
encodeURIComponent(uriComponent)

/**
 * 인코딩된 URI의 구성요소를 전달받아 이스케이프 처리 이전으로 디코딩한다.
 * @param {string} encodeURIComponent - 인코딩된 URI의 구성요소
 * @return {string} 디코딩된 URI의 구성요소
 */
decodeURI(encodeURIComponent)
```

#### 21.4.2 암묵적 전역

- 자바스크립트 엔진은 선언하지 않은 식별자에 값을 할당하면 전역 객체에 프로퍼티를 동적 생성한다. 이를 암묵적 전역이라 한다.
- 암묵적 전역으로 생성된 전역 프로퍼티는 전역 변수처럼 동작하지만 변수 선언 없이 단지 전역 객체의 프로퍼티로 추가되었을 뿐이다.
- 따라서 변수가 아니므로 변수 호이스팅이 발생하지 않는다.
- 암묵적 전역으로 생성된 프로퍼티는 변수가 아니라 단지 프로퍼티이므로 delete 연산자로 삭제할 수 있다.
- 전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다.

```js
console.log(x) // undefined
console.log(y) // ReferenceError: y is not defined

var x = 10

function foo() {
  y = 20 // window.y = 20;
  console.log(x + y)
}

foo() // 30

console.log(window.x) // 10
console.log(window.y) // 20

delete x
delete y

console.log(window.x) // 10
console.log(window.y) // undefined
```

## 22장 this

### 22.1 this 키워드

> [!NOTE]
> this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 **자기 참조 변수**다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.
>
> this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

- 객체의 동작을 나태는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다.
- 이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 **자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.**
- 따라서 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요하다. **이를 위해 자바스크립트는 this라는 특수한 식별자를 제공한다.**
- this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반적으로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다.

### 22.2 함수 호출 방식과 this 바인딩

- this 바인딩(this에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.
- 함수를 호출하는 방식
  - 일반 함수 호출
  - 메서드 호출
  - 생성자 함수 호출
  - Function.prototype.apply/call/bind 메서드에 의한 간접 호출

#### 22.2.1 일반 함수 호출

- 기본적으로 this에는 전역 객체가 바인딩된다.
- 다만 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.
- 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.
- 콜백 함수가 일반 함수로 호출된다면 콜백 함수 내부의 this에도 전역 객체가 바인딩된다.
- 메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메서드의 this 바인딩과 일치시키기 위한 방법이 필요하다.

  - this 바인딩을 변수에 할당해서 사용

    ```js
    var value = 1

    const obj = {
      value: 100,
      foo() {
        // this 바인딩(obj)을 변수 that에 할당한다.
        const that = this

        // 콜백 함수 내부에서 this 대신 that을 참조한다.
        setTimeout(function () {
          console.log(that.value) // 100
        }, 100)
      },
    }

    obj.foo()
    ```

  - Function.prototype.apply/call/bind로 this를 명시적으로 바인딩

    ```js
    var value = 1

    const obj = {
      value: 100,
      foo() {
        // 콜백 함수에 명시적으로 this를 바인딩한다.
        setTimeout(
          function () {
            console.log(this.value) // 100
          }.bind(this),
          100,
        )
      },
    }

    obj.foo()
    ```

#### 22.2.2 메서드 호출

- 메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표 연산자 앞에 기술한 객체가 바인딩된다.
- 주의할 것은 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다.

#### 22.2.3 생성자 함수 호출

- 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.

#### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출

- apply, call, bind 메서드는 Function.prototype의 메서드다. 즉, 이들 메서드는 모든 함수가 상속받아 사용할 수 있다.

##### apply, call 메서드

- apply, call 메서드의 본질적인 기능은 함수를 호출하는 것이다.
- 함수를 호출하면 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.
- arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하고자 할 때 유용하게 사용된다.

##### bind 메서드

- bind 메서드는 함수를 호출하지 않는다.
- 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다.
- 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.

| 함수 호출 방식                                             | this 바인딩                                                            |
| ---------------------------------------------------------- | ---------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                              |
| 메서드 호출                                                | 메서드를 호출한 객체                                                   |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                                 |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

## 23장 실행 컨텍스트

> [!NOTE]
> 실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념이다.

### 23.1 소스코드의 타입

- ECMAScript 사양은 소스코드(ECMAScript code)를 4가지 타입으로 구분한다. 4가지 타입의 소스코드는 실행 컨텍스트를 생성한다.
- 소스코드(실행 가능한 코드)를 4가지 타입으로 구분하는 이유는 **소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.**

#### 1. 전역 코드

- 전역에 존재하는 소스코드. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
- 전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다.
- 그리고 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 한다.
- 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.

#### 2. 함수 코드

- 함수 내부에 존재하는 소스코드. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
- 함수 코드는 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리해야 한다.
- 그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다.
- 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.

#### 3. eval 코드

- 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드
- eval 코드는 strict mode에서 자신만의 독자적인 스코프를 생성한다.
- 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다.

#### 4. 모듈 코드

- 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.
- 모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다.
- 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.

### 23.2 소스코드의 평가와 실행

- 자바스크립트 엔진은 소스코드를 2개의 과정, 즉 **"소스코드의 평가"**와 **"소스코드의 실행"** 과정으로 나누어 처리한다.
- 소스코드의 평가 과정
  - 실행 컨텍스트 생성
  - 변수, 함수 등의 선언문만 먼저 실행
  - 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록
- 소스코드의 실행 과정(런타임)
  - 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다.
  - 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.

### 23.3 실행 컨텍스트의 역할

> [!NOTE]
> 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

- 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.

  1.  선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.
  2.  스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.
  3.  현재 실행 중인 코드의 실행 순서를 변경(예를 들어, 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.

- 실행 컨텍스트는 **식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.**
- 식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리한다.

### 23.4 실행 컨텍스트 스택

> [!NOTE]
> 실행 컨텍스트 스택은 스택 자료구조로 코드의 실행 순서를 관리한다.

- 소스코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓인다.
- 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트다.
- 따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 실행 중인 실행 컨텍스트(running execution context)라고 부른다.

### 23.5 렉시컬 환경

> [!NOTE]
> 렉시컬 환경은 식별자와 식별자에 의해 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.

- 실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.
- 렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프를 생성해 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
- 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.

#### 1. 환경 레코드(Enviroment Record)

- 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값은 관리하는 저장소
- 소스코드의 타입에 따라 관리하는 내용에 차이가 있다.

#### 2. 외부 렉시컬 환경에 대한 참조(Outer Lexical Enviroment Reference)

- 상위 스코프 (외부 렉시컬 환경. 즉, 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경)
- 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.

### 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

> [!NOTE]
> 생성 -> 평가 -> 실행 -> 종료

```js
var x = 1
const y = 2

function foo(a) {
  var x = 3
  const y = 4

  function bar(b) {
    const z = 5
    console.log(a + b + x + y + z)
  }
  bar(10)
}

foo(20) // 42
```

#### 23.6.1 전역 객체 생성

- 전역 객체는 전역 코드가 평가되기 이전에 생성된다.
- 이때 전역 객체에는 빌트인 전역 프로퍼티와 빌트인 전역 함수, 그리고 표준 빌트인 객체가 추가되며 동작 환경에 따라 클라이언트 사이드 Web API 또는 특정 환경을 위한 호스트 객체를 포함한다.
- 전역 객체도 Object.prototype을 상속받는다. 즉, 전역 객체도 프로토타입 체인의 일원이다.

#### 23.6.2 전역 코드 평가

- 소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가한다.
- 전역 코드 평가 순서

##### 1. 전역 실행 컨텍스트 생성

- 먼저 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다.
- 이때 전역 실행 컨텍스트가 실행 중인 실행 컨텍스트(running execution context)가 된다.

##### 2. 전역 렉시컬 환경 생성

- 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩한다.
- 렉시컬 환경은 2개의 컴포넌트, 즉 환경 레코드(Enviroment Record)와 외부 렉시컬 환경에 대한 참조(OuterLexicalEnviromentReference)로 구성된다.

1. 전역 환경 레코드 생성

- 전역 변수를 관리하는 전역 스코프, 전역 객체의 빌트인 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 제공한다.
- 기존의 var 키워드로 선언한 전역 변수와 let, const 키워드로 선언한 전역 변수를 관리하기 위해 객체 환경 레코드(Object Enviroment Record)와 선언적 환경 레코드(Declarative Enviroment Record)로 구성되어 있다.

- 1.1 객체 환경 레코드 생성
  - var 키워드로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 등록하고 관리한다.
  - 객체 환경 레코드는 전역 객체 생성 시점에서 생성된 전역 객체 BindingObject와 연결된다.
  - 전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
  - 전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록한 다음, 암묵적으로 undefined를 바인딩한다.
- 1.2 선언적 환경 레코드 생성
  - 전역 코드 평가 과정에서 let, const 키워드로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리된다.
  - let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 **개념적인 블록** 내에 존재하게 된다. 여기서 말하는 개념적인 블록이 바로 전역 환경 레코드의 선언적 환경 레코드를 말한다.
  - 선언적 환경 레코드에서 관리하는 전역 변수는 선언 이후 초기화 단계, 즉 런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 일시적 사각지대(TDZ)에 빠지게 된다.

2. this 바인딩

- 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.
- 일반적으로 전역 코드에서 this는 전역 객체를 가리키므로 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에는 전역 객체가 바인딩된다.
- this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다.

3. 외부 렉시컬 환경에 대한 참조 결정

- 현재 평가 중인 소스코드를 포함하는 외부 소스코드와 렉시컬 환경, 즉 상위 스코프를 가리킨다. 이를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.
- 전역 코드를 포함하는 소스코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 null이 할당된다. 이는 **전역 렉시컬 환경이 스코프 체인의 종점에 존재함**을 의미한다.

#### 23.6.3 전역 코드 실행

- 전역 코드를 순차적으로 실행 하게 되면 변수를 값을 할당하고 함수를 호출하게 된다.
- 이때 변수 할당문 또는 함수 호출문을 실행하려면 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인해야 한다.
- 식별자는 스코프가 다르면 같은 이름을 가질 수 있기 때문에 어느 스코프의 식별자를 참조하면 되는지 결정하는 식별자 결정(identifier resolution) 작업이 필요하다.
- 식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다.
- 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경, 즉 상위 스코프로 이동하여 식별자를 검색한다. 이것이 바로 스코프 체인의 동작 원리다.
- 스코프 체인의 종점(전역 렉시컬 환경)까지 검색할 수 없는 식별자는 참조 에러(ReferenceError)를 발생시킨다.

#### 23.6.4 foo 함수 코드 평가

- foo 함수가 호출되면 전역 코드의 실행을 일시 중단하고 foo 함수 내부로 코드의 제어권이 이동한다.

##### 1. 함수 실행 컨텍스트 생성

- 먼저 foo 함수 실행 컨텍스트를 생성하고 함수 렉시컬 환경이 완성되며 실행 컨텍스트 스택에 푸시된다.
- 이때 실행 중인 실행 컨텍스트는 foo 함수 실행 컨텍스트가 된다.

##### 2. 함수 렉시컬 환경 생성

- foo 함수 렉시컬 환경을 생성하고 foo 함수 실행 컨텍스트에 바인딩한다.

1. 함수 환경 레코드 생성

- 함수 환경 레코드는 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.

2. this 바인딩

- 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다.
- [[ThisValue]] 내부 슬롯에 바인딩될 객체는 함수 호출 방식에 따라 결정된다.
- foo 함수는 일반 함수로 호출되었으므로 this는 전역 객체를 가리킨다. 따라서 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에는 전역 객체가 바인딩된다.

3. 외부 렉시컬 환경에 대한 참조 결정

- 외부 렉시컬 환경에 대한 참조에 foo 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.
- foo 함수는 전역 함수이므로 함수 정의가 평가된 시점은 전역 코드 평가 시점이다.
- 이 시점의 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트이므로 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경의 참조가 할당된다.
- 자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다.
- 자바스크립트 엔진은 **함수 정의를 평가하여 함수 객체를 생성할 때** 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 **함수의 상위 스코프를 함수 객체의 내부 슬롯 [[Environment]]에 저장**한다.
- 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당되는 것은 바로 함수의 상위 스코프를 가리키는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조다.
- 함수 객체의 내부 슬롯 [[Environment]]와 렉시컬 스코프는 **클로저**를 이해할 수 있는 중요한 단서다.

#### 23.6.5 foo 함수 코드 실행

- 이제 런타임이 시작되어 foo 함수의 소스코드가 순차적으로 실행되기 시작한다.
- 매개 변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 x, y에 값이 할당된다. 그리고 함수 bar가 호출된다.
- 이때 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다.
- 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자를 검색한다.

#### 23.6.6 bar 함수 코드 평가

- bar 함수가 호출되면 bar 함수 내부로 코드의 제어권이 이동한다. 그리고 bar 함수 코드를 평가하기 시작한다.
- 실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드 평가와 동일하다.

#### 23.6.7 bar 함수 코드 실행

- 런타임이 시작되어 bar 함수의 소스코드가 순차적으로 실행되기 시작한다.
- 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 z에 값이 할당된다. 그리고 `console.log(a + b + x + y + z)`가 실행된다.

##### 1. console 식별자 검색

- 먼저 console 식별자를 스코프 체인에서 검색한다. (bar -> foo -> 전역)
- console 식별자는 객체 환경 레코드의 BindingObject를 통해 전역 객체에서 찾을 수 있다.

##### 2. log 메서드 검색

- 이제 console 객체에서 log 메서드를 검색한다. 이때 console 객체의 프로토타입 체인을 통해 메서드를 검색한다.
- log 메서드는 상속된 프로퍼티가 아니라 console 객체가 직접 소유하는 프로퍼티다.

##### 3. 표현식 a+b+x+y+z의 평가

- 표현식 `a + b + x + y + z`를 평가하기 위해 a, b, x, y, z 식별자를 스코프 체인에서 검색한다.

##### 4. console.log 메서드 호출

- 표현식 `a + b + x + y + z`가 평가되어 생성한 값 42를 console.log 메서드에 전달하여 호출한다.

#### 23.6.8 bar 함수 코드 실행 종료

- console.log 메서드가 호출되고 종료하면 더는 실행할 코드가 없으므로 bar 함수 코드가 종료된다.
- 이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 팝되어 제거되고 foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.
- 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 제거되었다고 해서 bar 함수 렉시컬 환경까지 즉시 소멸되는 것은 아니다.
- 객체를 포함한 모든 값은 누군가에 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸한다.
- bar 함수 실행 컨텍스트가 소멸되었다 하더라도 만약 bar 함수 렉시컬 환경을 누군가 참조하고 있다면 bar 함수 렉시컬 환경은 소멸하지 않는다.

#### 23.6.9 foo 함수 코드 실행 종료

- bar 함수가 종료하면 더 이상 실행할 코드가 없으므로 foo 함수 코드의 실행이 종료된다.
- 이때 실행 컨택스트에서 foo 함수 실행 컨텍스트가 팝되어 제거되고 전역 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.

#### 23.6.10 전역 코드 실행 종료

- foo 함수가 종료하면 더는 실행할 전역 코드가 없으므로 전역 코드의 실행이 종료되고
- 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다.

### 23.7 실행 컨텍스트와 블록 레벨 스코프

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.
- let, const 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```js
let x = 1

if (true) {
  let x = 10
  console.log(x) // 10
}

console.log(x) // 1
```

- if 문의 코드 블록이 실행되면 if 문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.
- 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.
- 이때 새롭게 생성된 if 문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 if 문이 실행되기 이전의 전역 렉시컬 환경을 가리킨다.

## 24장 클로저

> [!NOTE]
> 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다.

- 클로저는 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.
- 클로저를 이해하려면 먼저 **"함수가 선언된 렉시컬 환경"**을 이해해야 한다.

### 24.1 렉시컬 스코프

> [!NOTE]
> 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프다.

- 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 **함수를 어디에 정의했는지**에 따라 상위 스코프를 결정한다. 이를 **렉시컬 스코프(정적 스코프)**라 한다.
- 함수의 상위 스코프는 함수를 정의한 위치에 의해 정적으로 결정되고 변하지 않는다.
- 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 이 렉시컬 환경은 자신의 "외부 렉시컬 환경에 대한 참조"를 통해 상위 렉시컬 환경과 연결된다.

### 24.2 함수 객체의 내부 슬롯 [[Environment]]

- 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 렉시컬 환경에 대한 참조를 저장한다.
- 따라서 함수 객체의 내부 슬롯 [[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프다.
- 또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장될 참조값이다.
- 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.
- 함수 코드를 평가하는 시점에서 함수 렉시컬 환경을 생성한다.
- 이때 함수 렉시컬 환경의 구성요소인 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.
- 즉, 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조는 바로 함수의 상위 스코프를 의미한다. 이것이 바로 함수 정의 위치에 따라 상위 스코프를 결정하는 렉시컬 스코프의 실체다.

### 24.3 클로저와 렉시컬 환경

- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저(closure)라고 부른다.
- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.
- 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(free variable)라고 부른다. 클로저란 "함수가 자유 변수에 대해 닫혀있다(closed)"라는 의미다.

### 24.4 클로저의 활용

- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.
- 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

```js
let num = 0

const increase = function () {
  return ++num
}

console.log(increase()) // 1
console.log(increase()) // 2
console.log(increase()) // 3
```

- 위 코드의 카운트 상태는 전역 변수를 통해 관리되고 있기 때문에 언제든지 누구나 접근할 수 있고 변경할 수 있다(암묵적 결합).
- 이는 의도치 않게 상태가 변경될 수 있다는 것을 의미하며, 오류로 이어질 수 있다.
- 따라서 카운트 상태를 안전하게 변경하고 유지하기 위해서는 increase 함수만인 num 변수를 참조하고 변경할 수 있게 하는 것이 바람직하다.

```js
const increase = function () {
  let num = 0

  return ++num
}

console.log(increase()) // 1
console.log(increase()) // 1
console.log(increase()) // 1
```

- 카운트 상태를 안전하게 변경하고 유지하기 위해 전역 변수 num을 increase 함수의 지역 변수로 변경하여 의도치 않은 상태 변경은 방지했다.
- 하지만 increase 함수가 호출될 때마다 지역 변수 num은 다시 선언되고 0으로 초기화되기 때문에 출력 결과는 언제나 1이다. 다시 말해, 상태가 변경되기 이전 상태를 유지하지 못한다.
- 클로저를 이용하면 카운트 상태를 increase 함수만 접근할 수 있게 하면서 이전 상태는 유지할 수 있다.

```js
const increase = (function () {
  let num = 0

  return function () {
    return ++num
  }
})()

console.log(increase()) // 1
console.log(increase()) // 2
console.log(increase()) // 3
```

- 위 코드가 실행되면 즉시 실행 함수가 호출되고 즉시 실행 함수가 반환한 함수가 increase 변수에 할당된다.
- 이때 즉시 실행 함수는 호출된 이후 소멸되지만 즉시 실행 함수가 반환한 클로저는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하고 있다.
- 즉시 실행 함수는 한 번만 실행되므로 increase가 호출될 때마다 num 변수가 재차 초기화될 일은 없을 것이다.
- 또한 num 변수는 외부에서 직접 접근할 수 없는 은닉된 private한 변수이므로 전역 변수를 사용했을 때와 같은 의도되지 않은 변경을 걱정할 필요도 없기 때문에 더 안정적인 프로그래밍이 가능하다.
- 이처럼 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.

### 24.5 캡슐화와 정보 은닉

- 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
- 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 한다.
- 정보 은닉은 정보를 보호하고 객체 간의 상호 의존성, 결합도를 낮추는 효과가 있다.
- 자바스크립트는 public, privat, protected 같은 접근 제한자를 제공하지 않는다. 즉, 객체의 모든 프로퍼티와 메서드는 기본적으로 public하다.
- 이처럼 자바스크립트는 정보 은닉을 완전하게 지원하지 않지만 새로운 ES2019에서는 해쉬 `#` prefix를 추가해 클래스에 private 필드를 정의할 수 있게 되었다.
